
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Gamification
 * 
 */
export type Gamification = $Result.DefaultSelection<Prisma.$GamificationPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Phrase
 * 
 */
export type Phrase = $Result.DefaultSelection<Prisma.$PhrasePayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model SpeakingSession
 * 
 */
export type SpeakingSession = $Result.DefaultSelection<Prisma.$SpeakingSessionPayload>
/**
 * Model SpeakingAttempt
 * 
 */
export type SpeakingAttempt = $Result.DefaultSelection<Prisma.$SpeakingAttemptPayload>
/**
 * Model ListeningSession
 * 
 */
export type ListeningSession = $Result.DefaultSelection<Prisma.$ListeningSessionPayload>
/**
 * Model PlacementTest
 * 
 */
export type PlacementTest = $Result.DefaultSelection<Prisma.$PlacementTestPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.gamification`: Exposes CRUD operations for the **Gamification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gamifications
    * const gamifications = await prisma.gamification.findMany()
    * ```
    */
  get gamification(): Prisma.GamificationDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.phrase`: Exposes CRUD operations for the **Phrase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phrases
    * const phrases = await prisma.phrase.findMany()
    * ```
    */
  get phrase(): Prisma.PhraseDelegate<ExtArgs>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs>;

  /**
   * `prisma.speakingSession`: Exposes CRUD operations for the **SpeakingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeakingSessions
    * const speakingSessions = await prisma.speakingSession.findMany()
    * ```
    */
  get speakingSession(): Prisma.SpeakingSessionDelegate<ExtArgs>;

  /**
   * `prisma.speakingAttempt`: Exposes CRUD operations for the **SpeakingAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeakingAttempts
    * const speakingAttempts = await prisma.speakingAttempt.findMany()
    * ```
    */
  get speakingAttempt(): Prisma.SpeakingAttemptDelegate<ExtArgs>;

  /**
   * `prisma.listeningSession`: Exposes CRUD operations for the **ListeningSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ListeningSessions
    * const listeningSessions = await prisma.listeningSession.findMany()
    * ```
    */
  get listeningSession(): Prisma.ListeningSessionDelegate<ExtArgs>;

  /**
   * `prisma.placementTest`: Exposes CRUD operations for the **PlacementTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlacementTests
    * const placementTests = await prisma.placementTest.findMany()
    * ```
    */
  get placementTest(): Prisma.PlacementTestDelegate<ExtArgs>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Gamification: 'Gamification',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Level: 'Level',
    Category: 'Category',
    Phrase: 'Phrase',
    UserProgress: 'UserProgress',
    SpeakingSession: 'SpeakingSession',
    SpeakingAttempt: 'SpeakingAttempt',
    ListeningSession: 'ListeningSession',
    PlacementTest: 'PlacementTest',
    Teacher: 'Teacher',
    Lesson: 'Lesson',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "gamification" | "achievement" | "userAchievement" | "level" | "category" | "phrase" | "userProgress" | "speakingSession" | "speakingAttempt" | "listeningSession" | "placementTest" | "teacher" | "lesson" | "payment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Gamification: {
        payload: Prisma.$GamificationPayload<ExtArgs>
        fields: Prisma.GamificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GamificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GamificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          findFirst: {
            args: Prisma.GamificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GamificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          findMany: {
            args: Prisma.GamificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>[]
          }
          create: {
            args: Prisma.GamificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          createMany: {
            args: Prisma.GamificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GamificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>[]
          }
          delete: {
            args: Prisma.GamificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          update: {
            args: Prisma.GamificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          deleteMany: {
            args: Prisma.GamificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GamificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GamificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GamificationPayload>
          }
          aggregate: {
            args: Prisma.GamificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGamification>
          }
          groupBy: {
            args: Prisma.GamificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GamificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.GamificationCountArgs<ExtArgs>
            result: $Utils.Optional<GamificationCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Phrase: {
        payload: Prisma.$PhrasePayload<ExtArgs>
        fields: Prisma.PhraseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhraseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhraseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          findFirst: {
            args: Prisma.PhraseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhraseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          findMany: {
            args: Prisma.PhraseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>[]
          }
          create: {
            args: Prisma.PhraseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          createMany: {
            args: Prisma.PhraseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PhraseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>[]
          }
          delete: {
            args: Prisma.PhraseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          update: {
            args: Prisma.PhraseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          deleteMany: {
            args: Prisma.PhraseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhraseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhraseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhrasePayload>
          }
          aggregate: {
            args: Prisma.PhraseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhrase>
          }
          groupBy: {
            args: Prisma.PhraseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhraseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhraseCountArgs<ExtArgs>
            result: $Utils.Optional<PhraseCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      SpeakingSession: {
        payload: Prisma.$SpeakingSessionPayload<ExtArgs>
        fields: Prisma.SpeakingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>
          }
          findFirst: {
            args: Prisma.SpeakingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>
          }
          findMany: {
            args: Prisma.SpeakingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>[]
          }
          create: {
            args: Prisma.SpeakingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>
          }
          createMany: {
            args: Prisma.SpeakingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeakingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>[]
          }
          delete: {
            args: Prisma.SpeakingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>
          }
          update: {
            args: Prisma.SpeakingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>
          }
          deleteMany: {
            args: Prisma.SpeakingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingSessionPayload>
          }
          aggregate: {
            args: Prisma.SpeakingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakingSession>
          }
          groupBy: {
            args: Prisma.SpeakingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeakingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakingSessionCountAggregateOutputType> | number
          }
        }
      }
      SpeakingAttempt: {
        payload: Prisma.$SpeakingAttemptPayload<ExtArgs>
        fields: Prisma.SpeakingAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakingAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakingAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>
          }
          findFirst: {
            args: Prisma.SpeakingAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakingAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>
          }
          findMany: {
            args: Prisma.SpeakingAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>[]
          }
          create: {
            args: Prisma.SpeakingAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>
          }
          createMany: {
            args: Prisma.SpeakingAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeakingAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>[]
          }
          delete: {
            args: Prisma.SpeakingAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>
          }
          update: {
            args: Prisma.SpeakingAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>
          }
          deleteMany: {
            args: Prisma.SpeakingAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakingAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpeakingAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakingAttemptPayload>
          }
          aggregate: {
            args: Prisma.SpeakingAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakingAttempt>
          }
          groupBy: {
            args: Prisma.SpeakingAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakingAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeakingAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakingAttemptCountAggregateOutputType> | number
          }
        }
      }
      ListeningSession: {
        payload: Prisma.$ListeningSessionPayload<ExtArgs>
        fields: Prisma.ListeningSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListeningSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListeningSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>
          }
          findFirst: {
            args: Prisma.ListeningSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListeningSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>
          }
          findMany: {
            args: Prisma.ListeningSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>[]
          }
          create: {
            args: Prisma.ListeningSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>
          }
          createMany: {
            args: Prisma.ListeningSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListeningSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>[]
          }
          delete: {
            args: Prisma.ListeningSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>
          }
          update: {
            args: Prisma.ListeningSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>
          }
          deleteMany: {
            args: Prisma.ListeningSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListeningSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ListeningSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListeningSessionPayload>
          }
          aggregate: {
            args: Prisma.ListeningSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListeningSession>
          }
          groupBy: {
            args: Prisma.ListeningSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListeningSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListeningSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ListeningSessionCountAggregateOutputType> | number
          }
        }
      }
      PlacementTest: {
        payload: Prisma.$PlacementTestPayload<ExtArgs>
        fields: Prisma.PlacementTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlacementTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlacementTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>
          }
          findFirst: {
            args: Prisma.PlacementTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlacementTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>
          }
          findMany: {
            args: Prisma.PlacementTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>[]
          }
          create: {
            args: Prisma.PlacementTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>
          }
          createMany: {
            args: Prisma.PlacementTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlacementTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>[]
          }
          delete: {
            args: Prisma.PlacementTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>
          }
          update: {
            args: Prisma.PlacementTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>
          }
          deleteMany: {
            args: Prisma.PlacementTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlacementTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlacementTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementTestPayload>
          }
          aggregate: {
            args: Prisma.PlacementTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlacementTest>
          }
          groupBy: {
            args: Prisma.PlacementTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlacementTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlacementTestCountArgs<ExtArgs>
            result: $Utils.Optional<PlacementTestCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    progress: number
    achievements: number
    lessons: number
    payments: number
    speakingSessions: number
    listeningSessions: number
    placementTests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | UserCountOutputTypeCountProgressArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    lessons?: boolean | UserCountOutputTypeCountLessonsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    speakingSessions?: boolean | UserCountOutputTypeCountSpeakingSessionsArgs
    listeningSessions?: boolean | UserCountOutputTypeCountListeningSessionsArgs
    placementTests?: boolean | UserCountOutputTypeCountPlacementTestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSpeakingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListeningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlacementTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementTestWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userAchievements: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | AchievementCountOutputTypeCountUserAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type LevelCountOutputType
   */

  export type LevelCountOutputType = {
    phrases: number
  }

  export type LevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrases?: boolean | LevelCountOutputTypeCountPhrasesArgs
  }

  // Custom InputTypes
  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     */
    select?: LevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountPhrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    phrases: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrases?: boolean | CategoryCountOutputTypeCountPhrasesArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPhrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseWhereInput
  }


  /**
   * Count Type PhraseCountOutputType
   */

  export type PhraseCountOutputType = {
    progress: number
    speakingAttempts: number
  }

  export type PhraseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | PhraseCountOutputTypeCountProgressArgs
    speakingAttempts?: boolean | PhraseCountOutputTypeCountSpeakingAttemptsArgs
  }

  // Custom InputTypes
  /**
   * PhraseCountOutputType without action
   */
  export type PhraseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhraseCountOutputType
     */
    select?: PhraseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhraseCountOutputType without action
   */
  export type PhraseCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * PhraseCountOutputType without action
   */
  export type PhraseCountOutputTypeCountSpeakingAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingAttemptWhereInput
  }


  /**
   * Count Type SpeakingSessionCountOutputType
   */

  export type SpeakingSessionCountOutputType = {
    attempts: number
  }

  export type SpeakingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | SpeakingSessionCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * SpeakingSessionCountOutputType without action
   */
  export type SpeakingSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSessionCountOutputType
     */
    select?: SpeakingSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpeakingSessionCountOutputType without action
   */
  export type SpeakingSessionCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingAttemptWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    lessons: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | TeacherCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatar: string | null
    phone: string | null
    birthDate: Date | null
    country: string | null
    timezone: string | null
    level: string | null
    emailVerified: boolean | null
    refreshToken: string | null
    lastLogin: Date | null
    subscriptionStatus: string | null
    subscriptionEndsAt: Date | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    avatar: string | null
    phone: string | null
    birthDate: Date | null
    country: string | null
    timezone: string | null
    level: string | null
    emailVerified: boolean | null
    refreshToken: string | null
    lastLogin: Date | null
    subscriptionStatus: string | null
    subscriptionEndsAt: Date | null
    stripeCustomerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    avatar: number
    phone: number
    birthDate: number
    country: number
    timezone: number
    level: number
    emailVerified: number
    refreshToken: number
    lastLogin: number
    subscriptionStatus: number
    subscriptionEndsAt: number
    stripeCustomerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatar?: true
    phone?: true
    birthDate?: true
    country?: true
    timezone?: true
    level?: true
    emailVerified?: true
    refreshToken?: true
    lastLogin?: true
    subscriptionStatus?: true
    subscriptionEndsAt?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatar?: true
    phone?: true
    birthDate?: true
    country?: true
    timezone?: true
    level?: true
    emailVerified?: true
    refreshToken?: true
    lastLogin?: true
    subscriptionStatus?: true
    subscriptionEndsAt?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    avatar?: true
    phone?: true
    birthDate?: true
    country?: true
    timezone?: true
    level?: true
    emailVerified?: true
    refreshToken?: true
    lastLogin?: true
    subscriptionStatus?: true
    subscriptionEndsAt?: true
    stripeCustomerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    avatar: string | null
    phone: string | null
    birthDate: Date | null
    country: string
    timezone: string
    level: string
    emailVerified: boolean
    refreshToken: string | null
    lastLogin: Date | null
    subscriptionStatus: string
    subscriptionEndsAt: Date | null
    stripeCustomerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    phone?: boolean
    birthDate?: boolean
    country?: boolean
    timezone?: boolean
    level?: boolean
    emailVerified?: boolean
    refreshToken?: boolean
    lastLogin?: boolean
    subscriptionStatus?: boolean
    subscriptionEndsAt?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progress?: boolean | User$progressArgs<ExtArgs>
    gamification?: boolean | User$gamificationArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    lessons?: boolean | User$lessonsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    speakingSessions?: boolean | User$speakingSessionsArgs<ExtArgs>
    listeningSessions?: boolean | User$listeningSessionsArgs<ExtArgs>
    placementTests?: boolean | User$placementTestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    phone?: boolean
    birthDate?: boolean
    country?: boolean
    timezone?: boolean
    level?: boolean
    emailVerified?: boolean
    refreshToken?: boolean
    lastLogin?: boolean
    subscriptionStatus?: boolean
    subscriptionEndsAt?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    phone?: boolean
    birthDate?: boolean
    country?: boolean
    timezone?: boolean
    level?: boolean
    emailVerified?: boolean
    refreshToken?: boolean
    lastLogin?: boolean
    subscriptionStatus?: boolean
    subscriptionEndsAt?: boolean
    stripeCustomerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | User$progressArgs<ExtArgs>
    gamification?: boolean | User$gamificationArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    lessons?: boolean | User$lessonsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    speakingSessions?: boolean | User$speakingSessionsArgs<ExtArgs>
    listeningSessions?: boolean | User$listeningSessionsArgs<ExtArgs>
    placementTests?: boolean | User$placementTestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      gamification: Prisma.$GamificationPayload<ExtArgs> | null
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      speakingSessions: Prisma.$SpeakingSessionPayload<ExtArgs>[]
      listeningSessions: Prisma.$ListeningSessionPayload<ExtArgs>[]
      placementTests: Prisma.$PlacementTestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      avatar: string | null
      phone: string | null
      birthDate: Date | null
      country: string
      timezone: string
      level: string
      emailVerified: boolean
      refreshToken: string | null
      lastLogin: Date | null
      subscriptionStatus: string
      subscriptionEndsAt: Date | null
      stripeCustomerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    progress<T extends User$progressArgs<ExtArgs> = {}>(args?: Subset<T, User$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany"> | Null>
    gamification<T extends User$gamificationArgs<ExtArgs> = {}>(args?: Subset<T, User$gamificationArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    lessons<T extends User$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    speakingSessions<T extends User$speakingSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$speakingSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "findMany"> | Null>
    listeningSessions<T extends User$listeningSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$listeningSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "findMany"> | Null>
    placementTests<T extends User$placementTestsArgs<ExtArgs> = {}>(args?: Subset<T, User$placementTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly country: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly level: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly subscriptionStatus: FieldRef<"User", 'String'>
    readonly subscriptionEndsAt: FieldRef<"User", 'DateTime'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.progress
   */
  export type User$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * User.gamification
   */
  export type User$gamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    where?: GamificationWhereInput
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.lessons
   */
  export type User$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.speakingSessions
   */
  export type User$speakingSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    where?: SpeakingSessionWhereInput
    orderBy?: SpeakingSessionOrderByWithRelationInput | SpeakingSessionOrderByWithRelationInput[]
    cursor?: SpeakingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeakingSessionScalarFieldEnum | SpeakingSessionScalarFieldEnum[]
  }

  /**
   * User.listeningSessions
   */
  export type User$listeningSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    where?: ListeningSessionWhereInput
    orderBy?: ListeningSessionOrderByWithRelationInput | ListeningSessionOrderByWithRelationInput[]
    cursor?: ListeningSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListeningSessionScalarFieldEnum | ListeningSessionScalarFieldEnum[]
  }

  /**
   * User.placementTests
   */
  export type User$placementTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    where?: PlacementTestWhereInput
    orderBy?: PlacementTestOrderByWithRelationInput | PlacementTestOrderByWithRelationInput[]
    cursor?: PlacementTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementTestScalarFieldEnum | PlacementTestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Gamification
   */

  export type AggregateGamification = {
    _count: GamificationCountAggregateOutputType | null
    _avg: GamificationAvgAggregateOutputType | null
    _sum: GamificationSumAggregateOutputType | null
    _min: GamificationMinAggregateOutputType | null
    _max: GamificationMaxAggregateOutputType | null
  }

  export type GamificationAvgAggregateOutputType = {
    xp: number | null
    level: number | null
    xpToNextLevel: number | null
    coins: number | null
    gems: number | null
    streak: number | null
    maxStreak: number | null
  }

  export type GamificationSumAggregateOutputType = {
    xp: number | null
    level: number | null
    xpToNextLevel: number | null
    coins: number | null
    gems: number | null
    streak: number | null
    maxStreak: number | null
  }

  export type GamificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    xp: number | null
    level: number | null
    xpToNextLevel: number | null
    coins: number | null
    gems: number | null
    streak: number | null
    maxStreak: number | null
    lastActiveDate: Date | null
    rank: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GamificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    xp: number | null
    level: number | null
    xpToNextLevel: number | null
    coins: number | null
    gems: number | null
    streak: number | null
    maxStreak: number | null
    lastActiveDate: Date | null
    rank: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GamificationCountAggregateOutputType = {
    id: number
    userId: number
    xp: number
    level: number
    xpToNextLevel: number
    coins: number
    gems: number
    streak: number
    maxStreak: number
    lastActiveDate: number
    rank: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GamificationAvgAggregateInputType = {
    xp?: true
    level?: true
    xpToNextLevel?: true
    coins?: true
    gems?: true
    streak?: true
    maxStreak?: true
  }

  export type GamificationSumAggregateInputType = {
    xp?: true
    level?: true
    xpToNextLevel?: true
    coins?: true
    gems?: true
    streak?: true
    maxStreak?: true
  }

  export type GamificationMinAggregateInputType = {
    id?: true
    userId?: true
    xp?: true
    level?: true
    xpToNextLevel?: true
    coins?: true
    gems?: true
    streak?: true
    maxStreak?: true
    lastActiveDate?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GamificationMaxAggregateInputType = {
    id?: true
    userId?: true
    xp?: true
    level?: true
    xpToNextLevel?: true
    coins?: true
    gems?: true
    streak?: true
    maxStreak?: true
    lastActiveDate?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GamificationCountAggregateInputType = {
    id?: true
    userId?: true
    xp?: true
    level?: true
    xpToNextLevel?: true
    coins?: true
    gems?: true
    streak?: true
    maxStreak?: true
    lastActiveDate?: true
    rank?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GamificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gamification to aggregate.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gamifications
    **/
    _count?: true | GamificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GamificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GamificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GamificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GamificationMaxAggregateInputType
  }

  export type GetGamificationAggregateType<T extends GamificationAggregateArgs> = {
        [P in keyof T & keyof AggregateGamification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGamification[P]>
      : GetScalarType<T[P], AggregateGamification[P]>
  }




  export type GamificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GamificationWhereInput
    orderBy?: GamificationOrderByWithAggregationInput | GamificationOrderByWithAggregationInput[]
    by: GamificationScalarFieldEnum[] | GamificationScalarFieldEnum
    having?: GamificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GamificationCountAggregateInputType | true
    _avg?: GamificationAvgAggregateInputType
    _sum?: GamificationSumAggregateInputType
    _min?: GamificationMinAggregateInputType
    _max?: GamificationMaxAggregateInputType
  }

  export type GamificationGroupByOutputType = {
    id: string
    userId: string
    xp: number
    level: number
    xpToNextLevel: number
    coins: number
    gems: number
    streak: number
    maxStreak: number
    lastActiveDate: Date
    rank: string
    createdAt: Date
    updatedAt: Date
    _count: GamificationCountAggregateOutputType | null
    _avg: GamificationAvgAggregateOutputType | null
    _sum: GamificationSumAggregateOutputType | null
    _min: GamificationMinAggregateOutputType | null
    _max: GamificationMaxAggregateOutputType | null
  }

  type GetGamificationGroupByPayload<T extends GamificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GamificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GamificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GamificationGroupByOutputType[P]>
            : GetScalarType<T[P], GamificationGroupByOutputType[P]>
        }
      >
    >


  export type GamificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    xp?: boolean
    level?: boolean
    xpToNextLevel?: boolean
    coins?: boolean
    gems?: boolean
    streak?: boolean
    maxStreak?: boolean
    lastActiveDate?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gamification"]>

  export type GamificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    xp?: boolean
    level?: boolean
    xpToNextLevel?: boolean
    coins?: boolean
    gems?: boolean
    streak?: boolean
    maxStreak?: boolean
    lastActiveDate?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gamification"]>

  export type GamificationSelectScalar = {
    id?: boolean
    userId?: boolean
    xp?: boolean
    level?: boolean
    xpToNextLevel?: boolean
    coins?: boolean
    gems?: boolean
    streak?: boolean
    maxStreak?: boolean
    lastActiveDate?: boolean
    rank?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GamificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GamificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GamificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gamification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      xp: number
      level: number
      xpToNextLevel: number
      coins: number
      gems: number
      streak: number
      maxStreak: number
      lastActiveDate: Date
      rank: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gamification"]>
    composites: {}
  }

  type GamificationGetPayload<S extends boolean | null | undefined | GamificationDefaultArgs> = $Result.GetResult<Prisma.$GamificationPayload, S>

  type GamificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GamificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GamificationCountAggregateInputType | true
    }

  export interface GamificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gamification'], meta: { name: 'Gamification' } }
    /**
     * Find zero or one Gamification that matches the filter.
     * @param {GamificationFindUniqueArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GamificationFindUniqueArgs>(args: SelectSubset<T, GamificationFindUniqueArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gamification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GamificationFindUniqueOrThrowArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GamificationFindUniqueOrThrowArgs>(args: SelectSubset<T, GamificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gamification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationFindFirstArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GamificationFindFirstArgs>(args?: SelectSubset<T, GamificationFindFirstArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gamification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationFindFirstOrThrowArgs} args - Arguments to find a Gamification
     * @example
     * // Get one Gamification
     * const gamification = await prisma.gamification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GamificationFindFirstOrThrowArgs>(args?: SelectSubset<T, GamificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gamifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gamifications
     * const gamifications = await prisma.gamification.findMany()
     * 
     * // Get first 10 Gamifications
     * const gamifications = await prisma.gamification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gamificationWithIdOnly = await prisma.gamification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GamificationFindManyArgs>(args?: SelectSubset<T, GamificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gamification.
     * @param {GamificationCreateArgs} args - Arguments to create a Gamification.
     * @example
     * // Create one Gamification
     * const Gamification = await prisma.gamification.create({
     *   data: {
     *     // ... data to create a Gamification
     *   }
     * })
     * 
     */
    create<T extends GamificationCreateArgs>(args: SelectSubset<T, GamificationCreateArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gamifications.
     * @param {GamificationCreateManyArgs} args - Arguments to create many Gamifications.
     * @example
     * // Create many Gamifications
     * const gamification = await prisma.gamification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GamificationCreateManyArgs>(args?: SelectSubset<T, GamificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gamifications and returns the data saved in the database.
     * @param {GamificationCreateManyAndReturnArgs} args - Arguments to create many Gamifications.
     * @example
     * // Create many Gamifications
     * const gamification = await prisma.gamification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gamifications and only return the `id`
     * const gamificationWithIdOnly = await prisma.gamification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GamificationCreateManyAndReturnArgs>(args?: SelectSubset<T, GamificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Gamification.
     * @param {GamificationDeleteArgs} args - Arguments to delete one Gamification.
     * @example
     * // Delete one Gamification
     * const Gamification = await prisma.gamification.delete({
     *   where: {
     *     // ... filter to delete one Gamification
     *   }
     * })
     * 
     */
    delete<T extends GamificationDeleteArgs>(args: SelectSubset<T, GamificationDeleteArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gamification.
     * @param {GamificationUpdateArgs} args - Arguments to update one Gamification.
     * @example
     * // Update one Gamification
     * const gamification = await prisma.gamification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GamificationUpdateArgs>(args: SelectSubset<T, GamificationUpdateArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gamifications.
     * @param {GamificationDeleteManyArgs} args - Arguments to filter Gamifications to delete.
     * @example
     * // Delete a few Gamifications
     * const { count } = await prisma.gamification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GamificationDeleteManyArgs>(args?: SelectSubset<T, GamificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gamifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gamifications
     * const gamification = await prisma.gamification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GamificationUpdateManyArgs>(args: SelectSubset<T, GamificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gamification.
     * @param {GamificationUpsertArgs} args - Arguments to update or create a Gamification.
     * @example
     * // Update or create a Gamification
     * const gamification = await prisma.gamification.upsert({
     *   create: {
     *     // ... data to create a Gamification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gamification we want to update
     *   }
     * })
     */
    upsert<T extends GamificationUpsertArgs>(args: SelectSubset<T, GamificationUpsertArgs<ExtArgs>>): Prisma__GamificationClient<$Result.GetResult<Prisma.$GamificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gamifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationCountArgs} args - Arguments to filter Gamifications to count.
     * @example
     * // Count the number of Gamifications
     * const count = await prisma.gamification.count({
     *   where: {
     *     // ... the filter for the Gamifications we want to count
     *   }
     * })
    **/
    count<T extends GamificationCountArgs>(
      args?: Subset<T, GamificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GamificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gamification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GamificationAggregateArgs>(args: Subset<T, GamificationAggregateArgs>): Prisma.PrismaPromise<GetGamificationAggregateType<T>>

    /**
     * Group by Gamification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GamificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GamificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GamificationGroupByArgs['orderBy'] }
        : { orderBy?: GamificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GamificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGamificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gamification model
   */
  readonly fields: GamificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gamification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GamificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gamification model
   */ 
  interface GamificationFieldRefs {
    readonly id: FieldRef<"Gamification", 'String'>
    readonly userId: FieldRef<"Gamification", 'String'>
    readonly xp: FieldRef<"Gamification", 'Int'>
    readonly level: FieldRef<"Gamification", 'Int'>
    readonly xpToNextLevel: FieldRef<"Gamification", 'Int'>
    readonly coins: FieldRef<"Gamification", 'Int'>
    readonly gems: FieldRef<"Gamification", 'Int'>
    readonly streak: FieldRef<"Gamification", 'Int'>
    readonly maxStreak: FieldRef<"Gamification", 'Int'>
    readonly lastActiveDate: FieldRef<"Gamification", 'DateTime'>
    readonly rank: FieldRef<"Gamification", 'String'>
    readonly createdAt: FieldRef<"Gamification", 'DateTime'>
    readonly updatedAt: FieldRef<"Gamification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Gamification findUnique
   */
  export type GamificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where: GamificationWhereUniqueInput
  }

  /**
   * Gamification findUniqueOrThrow
   */
  export type GamificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where: GamificationWhereUniqueInput
  }

  /**
   * Gamification findFirst
   */
  export type GamificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gamifications.
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gamifications.
     */
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }

  /**
   * Gamification findFirstOrThrow
   */
  export type GamificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamification to fetch.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gamifications.
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gamifications.
     */
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }

  /**
   * Gamification findMany
   */
  export type GamificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter, which Gamifications to fetch.
     */
    where?: GamificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gamifications to fetch.
     */
    orderBy?: GamificationOrderByWithRelationInput | GamificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gamifications.
     */
    cursor?: GamificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gamifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gamifications.
     */
    skip?: number
    distinct?: GamificationScalarFieldEnum | GamificationScalarFieldEnum[]
  }

  /**
   * Gamification create
   */
  export type GamificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Gamification.
     */
    data: XOR<GamificationCreateInput, GamificationUncheckedCreateInput>
  }

  /**
   * Gamification createMany
   */
  export type GamificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gamifications.
     */
    data: GamificationCreateManyInput | GamificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gamification createManyAndReturn
   */
  export type GamificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Gamifications.
     */
    data: GamificationCreateManyInput | GamificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gamification update
   */
  export type GamificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Gamification.
     */
    data: XOR<GamificationUpdateInput, GamificationUncheckedUpdateInput>
    /**
     * Choose, which Gamification to update.
     */
    where: GamificationWhereUniqueInput
  }

  /**
   * Gamification updateMany
   */
  export type GamificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gamifications.
     */
    data: XOR<GamificationUpdateManyMutationInput, GamificationUncheckedUpdateManyInput>
    /**
     * Filter which Gamifications to update
     */
    where?: GamificationWhereInput
  }

  /**
   * Gamification upsert
   */
  export type GamificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Gamification to update in case it exists.
     */
    where: GamificationWhereUniqueInput
    /**
     * In case the Gamification found by the `where` argument doesn't exist, create a new Gamification with this data.
     */
    create: XOR<GamificationCreateInput, GamificationUncheckedCreateInput>
    /**
     * In case the Gamification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GamificationUpdateInput, GamificationUncheckedUpdateInput>
  }

  /**
   * Gamification delete
   */
  export type GamificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
    /**
     * Filter which Gamification to delete.
     */
    where: GamificationWhereUniqueInput
  }

  /**
   * Gamification deleteMany
   */
  export type GamificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gamifications to delete
     */
    where?: GamificationWhereInput
  }

  /**
   * Gamification without action
   */
  export type GamificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gamification
     */
    select?: GamificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GamificationInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    xpReward: number | null
    coinsReward: number | null
    gemsReward: number | null
    requirement: number | null
  }

  export type AchievementSumAggregateOutputType = {
    xpReward: number | null
    coinsReward: number | null
    gemsReward: number | null
    requirement: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: string | null
    xpReward: number | null
    coinsReward: number | null
    gemsReward: number | null
    requirement: number | null
    isSecret: boolean | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: string | null
    xpReward: number | null
    coinsReward: number | null
    gemsReward: number | null
    requirement: number | null
    isSecret: boolean | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    icon: number
    category: number
    xpReward: number
    coinsReward: number
    gemsReward: number
    requirement: number
    isSecret: number
    createdAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    xpReward?: true
    coinsReward?: true
    gemsReward?: true
    requirement?: true
  }

  export type AchievementSumAggregateInputType = {
    xpReward?: true
    coinsReward?: true
    gemsReward?: true
    requirement?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    xpReward?: true
    coinsReward?: true
    gemsReward?: true
    requirement?: true
    isSecret?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    xpReward?: true
    coinsReward?: true
    gemsReward?: true
    requirement?: true
    isSecret?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    xpReward?: true
    coinsReward?: true
    gemsReward?: true
    requirement?: true
    isSecret?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    title: string
    description: string
    icon: string
    category: string
    xpReward: number
    coinsReward: number
    gemsReward: number
    requirement: number
    isSecret: boolean
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    xpReward?: boolean
    coinsReward?: boolean
    gemsReward?: boolean
    requirement?: boolean
    isSecret?: boolean
    createdAt?: boolean
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    xpReward?: boolean
    coinsReward?: boolean
    gemsReward?: boolean
    requirement?: boolean
    isSecret?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    xpReward?: boolean
    coinsReward?: boolean
    gemsReward?: boolean
    requirement?: boolean
    isSecret?: boolean
    createdAt?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      icon: string
      category: string
      xpReward: number
      coinsReward: number
      gemsReward: number
      requirement: number
      isSecret: boolean
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAchievements<T extends Achievement$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'String'>
    readonly xpReward: FieldRef<"Achievement", 'Int'>
    readonly coinsReward: FieldRef<"Achievement", 'Int'>
    readonly gemsReward: FieldRef<"Achievement", 'Int'>
    readonly requirement: FieldRef<"Achievement", 'Int'>
    readonly isSecret: FieldRef<"Achievement", 'Boolean'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement.userAchievements
   */
  export type Achievement$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    progress: number | null
    unlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    progress: number | null
    unlocked: boolean | null
    unlockedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    progress: number
    unlocked: number
    unlockedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserAchievementSumAggregateInputType = {
    progress?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    unlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    unlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    progress?: true
    unlocked?: true
    unlockedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    progress: number
    unlocked: boolean
    unlockedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    unlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    unlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    progress?: boolean
    unlocked?: boolean
    unlockedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      progress: number
      unlocked: boolean
      unlockedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly progress: FieldRef<"UserAchievement", 'Int'>
    readonly unlocked: FieldRef<"UserAchievement", 'Boolean'>
    readonly unlockedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly createdAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly updatedAt: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelAvgAggregateOutputType = {
    order: number | null
  }

  export type LevelSumAggregateOutputType = {
    order: number | null
  }

  export type LevelMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
  }

  export type LevelMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    createdAt: number
    _all: number
  }


  export type LevelAvgAggregateInputType = {
    order?: true
  }

  export type LevelSumAggregateInputType = {
    order?: true
  }

  export type LevelMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _avg?: LevelAvgAggregateInputType
    _sum?: LevelSumAggregateInputType
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: string
    name: string
    description: string
    order: number
    createdAt: Date
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    phrases?: boolean | Level$phrasesArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["level"]>

  export type LevelSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrases?: boolean | Level$phrasesArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {
      phrases: Prisma.$PhrasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      order: number
      createdAt: Date
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {LevelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LevelCreateManyAndReturnArgs>(args?: SelectSubset<T, LevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phrases<T extends Level$phrasesArgs<ExtArgs> = {}>(args?: Subset<T, Level$phrasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */ 
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'String'>
    readonly name: FieldRef<"Level", 'String'>
    readonly description: FieldRef<"Level", 'String'>
    readonly order: FieldRef<"Level", 'Int'>
    readonly createdAt: FieldRef<"Level", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Level createManyAndReturn
   */
  export type LevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
  }

  /**
   * Level.phrases
   */
  export type Level$phrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    where?: PhraseWhereInput
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    cursor?: PhraseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type CategorySumAggregateOutputType = {
    order: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    order: number | null
    createdAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    order: number | null
    createdAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    order: number
    createdAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    order?: true
  }

  export type CategorySumAggregateInputType = {
    order?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    order: number
    createdAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
    phrases?: boolean | Category$phrasesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phrases?: boolean | Category$phrasesArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      phrases: Prisma.$PhrasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      order: number
      createdAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phrases<T extends Category$phrasesArgs<ExtArgs> = {}>(args?: Subset<T, Category$phrasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly icon: FieldRef<"Category", 'String'>
    readonly order: FieldRef<"Category", 'Int'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.phrases
   */
  export type Category$phrasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    where?: PhraseWhereInput
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    cursor?: PhraseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Phrase
   */

  export type AggregatePhrase = {
    _count: PhraseCountAggregateOutputType | null
    _avg: PhraseAvgAggregateOutputType | null
    _sum: PhraseSumAggregateOutputType | null
    _min: PhraseMinAggregateOutputType | null
    _max: PhraseMaxAggregateOutputType | null
  }

  export type PhraseAvgAggregateOutputType = {
    difficulty: number | null
  }

  export type PhraseSumAggregateOutputType = {
    difficulty: number | null
  }

  export type PhraseMinAggregateOutputType = {
    id: string | null
    text: string | null
    translation: string | null
    audioUrl: string | null
    imageUrl: string | null
    levelId: string | null
    categoryId: string | null
    difficulty: number | null
    ipaTranscription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhraseMaxAggregateOutputType = {
    id: string | null
    text: string | null
    translation: string | null
    audioUrl: string | null
    imageUrl: string | null
    levelId: string | null
    categoryId: string | null
    difficulty: number | null
    ipaTranscription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PhraseCountAggregateOutputType = {
    id: number
    text: number
    translation: number
    audioUrl: number
    imageUrl: number
    levelId: number
    categoryId: number
    difficulty: number
    tags: number
    ipaTranscription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PhraseAvgAggregateInputType = {
    difficulty?: true
  }

  export type PhraseSumAggregateInputType = {
    difficulty?: true
  }

  export type PhraseMinAggregateInputType = {
    id?: true
    text?: true
    translation?: true
    audioUrl?: true
    imageUrl?: true
    levelId?: true
    categoryId?: true
    difficulty?: true
    ipaTranscription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhraseMaxAggregateInputType = {
    id?: true
    text?: true
    translation?: true
    audioUrl?: true
    imageUrl?: true
    levelId?: true
    categoryId?: true
    difficulty?: true
    ipaTranscription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PhraseCountAggregateInputType = {
    id?: true
    text?: true
    translation?: true
    audioUrl?: true
    imageUrl?: true
    levelId?: true
    categoryId?: true
    difficulty?: true
    tags?: true
    ipaTranscription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PhraseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phrase to aggregate.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phrases
    **/
    _count?: true | PhraseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhraseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhraseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhraseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhraseMaxAggregateInputType
  }

  export type GetPhraseAggregateType<T extends PhraseAggregateArgs> = {
        [P in keyof T & keyof AggregatePhrase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhrase[P]>
      : GetScalarType<T[P], AggregatePhrase[P]>
  }




  export type PhraseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhraseWhereInput
    orderBy?: PhraseOrderByWithAggregationInput | PhraseOrderByWithAggregationInput[]
    by: PhraseScalarFieldEnum[] | PhraseScalarFieldEnum
    having?: PhraseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhraseCountAggregateInputType | true
    _avg?: PhraseAvgAggregateInputType
    _sum?: PhraseSumAggregateInputType
    _min?: PhraseMinAggregateInputType
    _max?: PhraseMaxAggregateInputType
  }

  export type PhraseGroupByOutputType = {
    id: string
    text: string
    translation: string
    audioUrl: string | null
    imageUrl: string | null
    levelId: string
    categoryId: string
    difficulty: number
    tags: string[]
    ipaTranscription: string | null
    createdAt: Date
    updatedAt: Date
    _count: PhraseCountAggregateOutputType | null
    _avg: PhraseAvgAggregateOutputType | null
    _sum: PhraseSumAggregateOutputType | null
    _min: PhraseMinAggregateOutputType | null
    _max: PhraseMaxAggregateOutputType | null
  }

  type GetPhraseGroupByPayload<T extends PhraseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhraseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhraseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhraseGroupByOutputType[P]>
            : GetScalarType<T[P], PhraseGroupByOutputType[P]>
        }
      >
    >


  export type PhraseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    translation?: boolean
    audioUrl?: boolean
    imageUrl?: boolean
    levelId?: boolean
    categoryId?: boolean
    difficulty?: boolean
    tags?: boolean
    ipaTranscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | LevelDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    progress?: boolean | Phrase$progressArgs<ExtArgs>
    speakingAttempts?: boolean | Phrase$speakingAttemptsArgs<ExtArgs>
    _count?: boolean | PhraseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phrase"]>

  export type PhraseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    translation?: boolean
    audioUrl?: boolean
    imageUrl?: boolean
    levelId?: boolean
    categoryId?: boolean
    difficulty?: boolean
    tags?: boolean
    ipaTranscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean | LevelDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phrase"]>

  export type PhraseSelectScalar = {
    id?: boolean
    text?: boolean
    translation?: boolean
    audioUrl?: boolean
    imageUrl?: boolean
    levelId?: boolean
    categoryId?: boolean
    difficulty?: boolean
    tags?: boolean
    ipaTranscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PhraseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | LevelDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    progress?: boolean | Phrase$progressArgs<ExtArgs>
    speakingAttempts?: boolean | Phrase$speakingAttemptsArgs<ExtArgs>
    _count?: boolean | PhraseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PhraseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    level?: boolean | LevelDefaultArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
  }

  export type $PhrasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Phrase"
    objects: {
      level: Prisma.$LevelPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs>
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      speakingAttempts: Prisma.$SpeakingAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      translation: string
      audioUrl: string | null
      imageUrl: string | null
      levelId: string
      categoryId: string
      difficulty: number
      tags: string[]
      ipaTranscription: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["phrase"]>
    composites: {}
  }

  type PhraseGetPayload<S extends boolean | null | undefined | PhraseDefaultArgs> = $Result.GetResult<Prisma.$PhrasePayload, S>

  type PhraseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhraseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhraseCountAggregateInputType | true
    }

  export interface PhraseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Phrase'], meta: { name: 'Phrase' } }
    /**
     * Find zero or one Phrase that matches the filter.
     * @param {PhraseFindUniqueArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhraseFindUniqueArgs>(args: SelectSubset<T, PhraseFindUniqueArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Phrase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhraseFindUniqueOrThrowArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhraseFindUniqueOrThrowArgs>(args: SelectSubset<T, PhraseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Phrase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseFindFirstArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhraseFindFirstArgs>(args?: SelectSubset<T, PhraseFindFirstArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Phrase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseFindFirstOrThrowArgs} args - Arguments to find a Phrase
     * @example
     * // Get one Phrase
     * const phrase = await prisma.phrase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhraseFindFirstOrThrowArgs>(args?: SelectSubset<T, PhraseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Phrases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phrases
     * const phrases = await prisma.phrase.findMany()
     * 
     * // Get first 10 Phrases
     * const phrases = await prisma.phrase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phraseWithIdOnly = await prisma.phrase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhraseFindManyArgs>(args?: SelectSubset<T, PhraseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Phrase.
     * @param {PhraseCreateArgs} args - Arguments to create a Phrase.
     * @example
     * // Create one Phrase
     * const Phrase = await prisma.phrase.create({
     *   data: {
     *     // ... data to create a Phrase
     *   }
     * })
     * 
     */
    create<T extends PhraseCreateArgs>(args: SelectSubset<T, PhraseCreateArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Phrases.
     * @param {PhraseCreateManyArgs} args - Arguments to create many Phrases.
     * @example
     * // Create many Phrases
     * const phrase = await prisma.phrase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhraseCreateManyArgs>(args?: SelectSubset<T, PhraseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Phrases and returns the data saved in the database.
     * @param {PhraseCreateManyAndReturnArgs} args - Arguments to create many Phrases.
     * @example
     * // Create many Phrases
     * const phrase = await prisma.phrase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Phrases and only return the `id`
     * const phraseWithIdOnly = await prisma.phrase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PhraseCreateManyAndReturnArgs>(args?: SelectSubset<T, PhraseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Phrase.
     * @param {PhraseDeleteArgs} args - Arguments to delete one Phrase.
     * @example
     * // Delete one Phrase
     * const Phrase = await prisma.phrase.delete({
     *   where: {
     *     // ... filter to delete one Phrase
     *   }
     * })
     * 
     */
    delete<T extends PhraseDeleteArgs>(args: SelectSubset<T, PhraseDeleteArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Phrase.
     * @param {PhraseUpdateArgs} args - Arguments to update one Phrase.
     * @example
     * // Update one Phrase
     * const phrase = await prisma.phrase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhraseUpdateArgs>(args: SelectSubset<T, PhraseUpdateArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Phrases.
     * @param {PhraseDeleteManyArgs} args - Arguments to filter Phrases to delete.
     * @example
     * // Delete a few Phrases
     * const { count } = await prisma.phrase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhraseDeleteManyArgs>(args?: SelectSubset<T, PhraseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phrases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phrases
     * const phrase = await prisma.phrase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhraseUpdateManyArgs>(args: SelectSubset<T, PhraseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Phrase.
     * @param {PhraseUpsertArgs} args - Arguments to update or create a Phrase.
     * @example
     * // Update or create a Phrase
     * const phrase = await prisma.phrase.upsert({
     *   create: {
     *     // ... data to create a Phrase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phrase we want to update
     *   }
     * })
     */
    upsert<T extends PhraseUpsertArgs>(args: SelectSubset<T, PhraseUpsertArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Phrases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseCountArgs} args - Arguments to filter Phrases to count.
     * @example
     * // Count the number of Phrases
     * const count = await prisma.phrase.count({
     *   where: {
     *     // ... the filter for the Phrases we want to count
     *   }
     * })
    **/
    count<T extends PhraseCountArgs>(
      args?: Subset<T, PhraseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhraseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phrase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhraseAggregateArgs>(args: Subset<T, PhraseAggregateArgs>): Prisma.PrismaPromise<GetPhraseAggregateType<T>>

    /**
     * Group by Phrase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhraseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhraseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhraseGroupByArgs['orderBy'] }
        : { orderBy?: PhraseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhraseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhraseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Phrase model
   */
  readonly fields: PhraseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phrase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhraseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    level<T extends LevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LevelDefaultArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progress<T extends Phrase$progressArgs<ExtArgs> = {}>(args?: Subset<T, Phrase$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany"> | Null>
    speakingAttempts<T extends Phrase$speakingAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, Phrase$speakingAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Phrase model
   */ 
  interface PhraseFieldRefs {
    readonly id: FieldRef<"Phrase", 'String'>
    readonly text: FieldRef<"Phrase", 'String'>
    readonly translation: FieldRef<"Phrase", 'String'>
    readonly audioUrl: FieldRef<"Phrase", 'String'>
    readonly imageUrl: FieldRef<"Phrase", 'String'>
    readonly levelId: FieldRef<"Phrase", 'String'>
    readonly categoryId: FieldRef<"Phrase", 'String'>
    readonly difficulty: FieldRef<"Phrase", 'Int'>
    readonly tags: FieldRef<"Phrase", 'String[]'>
    readonly ipaTranscription: FieldRef<"Phrase", 'String'>
    readonly createdAt: FieldRef<"Phrase", 'DateTime'>
    readonly updatedAt: FieldRef<"Phrase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Phrase findUnique
   */
  export type PhraseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase findUniqueOrThrow
   */
  export type PhraseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase findFirst
   */
  export type PhraseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phrases.
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phrases.
     */
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Phrase findFirstOrThrow
   */
  export type PhraseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrase to fetch.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phrases.
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phrases.
     */
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Phrase findMany
   */
  export type PhraseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter, which Phrases to fetch.
     */
    where?: PhraseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phrases to fetch.
     */
    orderBy?: PhraseOrderByWithRelationInput | PhraseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phrases.
     */
    cursor?: PhraseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phrases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phrases.
     */
    skip?: number
    distinct?: PhraseScalarFieldEnum | PhraseScalarFieldEnum[]
  }

  /**
   * Phrase create
   */
  export type PhraseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * The data needed to create a Phrase.
     */
    data: XOR<PhraseCreateInput, PhraseUncheckedCreateInput>
  }

  /**
   * Phrase createMany
   */
  export type PhraseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Phrases.
     */
    data: PhraseCreateManyInput | PhraseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Phrase createManyAndReturn
   */
  export type PhraseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Phrases.
     */
    data: PhraseCreateManyInput | PhraseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Phrase update
   */
  export type PhraseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * The data needed to update a Phrase.
     */
    data: XOR<PhraseUpdateInput, PhraseUncheckedUpdateInput>
    /**
     * Choose, which Phrase to update.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase updateMany
   */
  export type PhraseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Phrases.
     */
    data: XOR<PhraseUpdateManyMutationInput, PhraseUncheckedUpdateManyInput>
    /**
     * Filter which Phrases to update
     */
    where?: PhraseWhereInput
  }

  /**
   * Phrase upsert
   */
  export type PhraseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * The filter to search for the Phrase to update in case it exists.
     */
    where: PhraseWhereUniqueInput
    /**
     * In case the Phrase found by the `where` argument doesn't exist, create a new Phrase with this data.
     */
    create: XOR<PhraseCreateInput, PhraseUncheckedCreateInput>
    /**
     * In case the Phrase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhraseUpdateInput, PhraseUncheckedUpdateInput>
  }

  /**
   * Phrase delete
   */
  export type PhraseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
    /**
     * Filter which Phrase to delete.
     */
    where: PhraseWhereUniqueInput
  }

  /**
   * Phrase deleteMany
   */
  export type PhraseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Phrases to delete
     */
    where?: PhraseWhereInput
  }

  /**
   * Phrase.progress
   */
  export type Phrase$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * Phrase.speakingAttempts
   */
  export type Phrase$speakingAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    where?: SpeakingAttemptWhereInput
    orderBy?: SpeakingAttemptOrderByWithRelationInput | SpeakingAttemptOrderByWithRelationInput[]
    cursor?: SpeakingAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeakingAttemptScalarFieldEnum | SpeakingAttemptScalarFieldEnum[]
  }

  /**
   * Phrase without action
   */
  export type PhraseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Phrase
     */
    select?: PhraseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhraseInclude<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressAvgAggregateOutputType = {
    mastery: number | null
    attempts: number | null
    successes: number | null
    lastScore: number | null
    bestScore: number | null
    easeFactor: number | null
    interval: number | null
  }

  export type UserProgressSumAggregateOutputType = {
    mastery: number | null
    attempts: number | null
    successes: number | null
    lastScore: number | null
    bestScore: number | null
    easeFactor: number | null
    interval: number | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    phraseId: string | null
    mastery: number | null
    attempts: number | null
    successes: number | null
    lastScore: number | null
    bestScore: number | null
    easeFactor: number | null
    interval: number | null
    nextReview: Date | null
    lastPracticed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    phraseId: string | null
    mastery: number | null
    attempts: number | null
    successes: number | null
    lastScore: number | null
    bestScore: number | null
    easeFactor: number | null
    interval: number | null
    nextReview: Date | null
    lastPracticed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    phraseId: number
    mastery: number
    attempts: number
    successes: number
    lastScore: number
    bestScore: number
    easeFactor: number
    interval: number
    nextReview: number
    lastPracticed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProgressAvgAggregateInputType = {
    mastery?: true
    attempts?: true
    successes?: true
    lastScore?: true
    bestScore?: true
    easeFactor?: true
    interval?: true
  }

  export type UserProgressSumAggregateInputType = {
    mastery?: true
    attempts?: true
    successes?: true
    lastScore?: true
    bestScore?: true
    easeFactor?: true
    interval?: true
  }

  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    phraseId?: true
    mastery?: true
    attempts?: true
    successes?: true
    lastScore?: true
    bestScore?: true
    easeFactor?: true
    interval?: true
    nextReview?: true
    lastPracticed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    phraseId?: true
    mastery?: true
    attempts?: true
    successes?: true
    lastScore?: true
    bestScore?: true
    easeFactor?: true
    interval?: true
    nextReview?: true
    lastPracticed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    phraseId?: true
    mastery?: true
    attempts?: true
    successes?: true
    lastScore?: true
    bestScore?: true
    easeFactor?: true
    interval?: true
    nextReview?: true
    lastPracticed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _avg?: UserProgressAvgAggregateInputType
    _sum?: UserProgressSumAggregateInputType
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    phraseId: string
    mastery: number
    attempts: number
    successes: number
    lastScore: number
    bestScore: number
    easeFactor: number
    interval: number
    nextReview: Date
    lastPracticed: Date
    createdAt: Date
    updatedAt: Date
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phraseId?: boolean
    mastery?: boolean
    attempts?: boolean
    successes?: boolean
    lastScore?: boolean
    bestScore?: boolean
    easeFactor?: boolean
    interval?: boolean
    nextReview?: boolean
    lastPracticed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phraseId?: boolean
    mastery?: boolean
    attempts?: boolean
    successes?: boolean
    lastScore?: boolean
    bestScore?: boolean
    easeFactor?: boolean
    interval?: boolean
    nextReview?: boolean
    lastPracticed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    phraseId?: boolean
    mastery?: boolean
    attempts?: boolean
    successes?: boolean
    lastScore?: boolean
    bestScore?: boolean
    easeFactor?: boolean
    interval?: boolean
    nextReview?: boolean
    lastPracticed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      phrase: Prisma.$PhrasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      phraseId: string
      mastery: number
      attempts: number
      successes: number
      lastScore: number
      bestScore: number
      easeFactor: number
      interval: number
      nextReview: Date
      lastPracticed: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    phrase<T extends PhraseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhraseDefaultArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */ 
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly phraseId: FieldRef<"UserProgress", 'String'>
    readonly mastery: FieldRef<"UserProgress", 'Int'>
    readonly attempts: FieldRef<"UserProgress", 'Int'>
    readonly successes: FieldRef<"UserProgress", 'Int'>
    readonly lastScore: FieldRef<"UserProgress", 'Int'>
    readonly bestScore: FieldRef<"UserProgress", 'Int'>
    readonly easeFactor: FieldRef<"UserProgress", 'Float'>
    readonly interval: FieldRef<"UserProgress", 'Int'>
    readonly nextReview: FieldRef<"UserProgress", 'DateTime'>
    readonly lastPracticed: FieldRef<"UserProgress", 'DateTime'>
    readonly createdAt: FieldRef<"UserProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
  }


  /**
   * Model SpeakingSession
   */

  export type AggregateSpeakingSession = {
    _count: SpeakingSessionCountAggregateOutputType | null
    _avg: SpeakingSessionAvgAggregateOutputType | null
    _sum: SpeakingSessionSumAggregateOutputType | null
    _min: SpeakingSessionMinAggregateOutputType | null
    _max: SpeakingSessionMaxAggregateOutputType | null
  }

  export type SpeakingSessionAvgAggregateOutputType = {
    bestScore: number | null
    totalTime: number | null
  }

  export type SpeakingSessionSumAggregateOutputType = {
    bestScore: number | null
    totalTime: number | null
  }

  export type SpeakingSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bestScore: number | null
    startedAt: Date | null
    completedAt: Date | null
    totalTime: number | null
  }

  export type SpeakingSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bestScore: number | null
    startedAt: Date | null
    completedAt: Date | null
    totalTime: number | null
  }

  export type SpeakingSessionCountAggregateOutputType = {
    id: number
    userId: number
    bestScore: number
    startedAt: number
    completedAt: number
    totalTime: number
    _all: number
  }


  export type SpeakingSessionAvgAggregateInputType = {
    bestScore?: true
    totalTime?: true
  }

  export type SpeakingSessionSumAggregateInputType = {
    bestScore?: true
    totalTime?: true
  }

  export type SpeakingSessionMinAggregateInputType = {
    id?: true
    userId?: true
    bestScore?: true
    startedAt?: true
    completedAt?: true
    totalTime?: true
  }

  export type SpeakingSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    bestScore?: true
    startedAt?: true
    completedAt?: true
    totalTime?: true
  }

  export type SpeakingSessionCountAggregateInputType = {
    id?: true
    userId?: true
    bestScore?: true
    startedAt?: true
    completedAt?: true
    totalTime?: true
    _all?: true
  }

  export type SpeakingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingSession to aggregate.
     */
    where?: SpeakingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSessions to fetch.
     */
    orderBy?: SpeakingSessionOrderByWithRelationInput | SpeakingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeakingSessions
    **/
    _count?: true | SpeakingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeakingSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeakingSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakingSessionMaxAggregateInputType
  }

  export type GetSpeakingSessionAggregateType<T extends SpeakingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakingSession[P]>
      : GetScalarType<T[P], AggregateSpeakingSession[P]>
  }




  export type SpeakingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingSessionWhereInput
    orderBy?: SpeakingSessionOrderByWithAggregationInput | SpeakingSessionOrderByWithAggregationInput[]
    by: SpeakingSessionScalarFieldEnum[] | SpeakingSessionScalarFieldEnum
    having?: SpeakingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakingSessionCountAggregateInputType | true
    _avg?: SpeakingSessionAvgAggregateInputType
    _sum?: SpeakingSessionSumAggregateInputType
    _min?: SpeakingSessionMinAggregateInputType
    _max?: SpeakingSessionMaxAggregateInputType
  }

  export type SpeakingSessionGroupByOutputType = {
    id: string
    userId: string
    bestScore: number
    startedAt: Date
    completedAt: Date | null
    totalTime: number
    _count: SpeakingSessionCountAggregateOutputType | null
    _avg: SpeakingSessionAvgAggregateOutputType | null
    _sum: SpeakingSessionSumAggregateOutputType | null
    _min: SpeakingSessionMinAggregateOutputType | null
    _max: SpeakingSessionMaxAggregateOutputType | null
  }

  type GetSpeakingSessionGroupByPayload<T extends SpeakingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakingSessionGroupByOutputType[P]>
        }
      >
    >


  export type SpeakingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bestScore?: boolean
    startedAt?: boolean
    completedAt?: boolean
    totalTime?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempts?: boolean | SpeakingSession$attemptsArgs<ExtArgs>
    _count?: boolean | SpeakingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakingSession"]>

  export type SpeakingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bestScore?: boolean
    startedAt?: boolean
    completedAt?: boolean
    totalTime?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakingSession"]>

  export type SpeakingSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    bestScore?: boolean
    startedAt?: boolean
    completedAt?: boolean
    totalTime?: boolean
  }

  export type SpeakingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    attempts?: boolean | SpeakingSession$attemptsArgs<ExtArgs>
    _count?: boolean | SpeakingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpeakingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SpeakingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeakingSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      attempts: Prisma.$SpeakingAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bestScore: number
      startedAt: Date
      completedAt: Date | null
      totalTime: number
    }, ExtArgs["result"]["speakingSession"]>
    composites: {}
  }

  type SpeakingSessionGetPayload<S extends boolean | null | undefined | SpeakingSessionDefaultArgs> = $Result.GetResult<Prisma.$SpeakingSessionPayload, S>

  type SpeakingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpeakingSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpeakingSessionCountAggregateInputType | true
    }

  export interface SpeakingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeakingSession'], meta: { name: 'SpeakingSession' } }
    /**
     * Find zero or one SpeakingSession that matches the filter.
     * @param {SpeakingSessionFindUniqueArgs} args - Arguments to find a SpeakingSession
     * @example
     * // Get one SpeakingSession
     * const speakingSession = await prisma.speakingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakingSessionFindUniqueArgs>(args: SelectSubset<T, SpeakingSessionFindUniqueArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpeakingSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpeakingSessionFindUniqueOrThrowArgs} args - Arguments to find a SpeakingSession
     * @example
     * // Get one SpeakingSession
     * const speakingSession = await prisma.speakingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpeakingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSessionFindFirstArgs} args - Arguments to find a SpeakingSession
     * @example
     * // Get one SpeakingSession
     * const speakingSession = await prisma.speakingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakingSessionFindFirstArgs>(args?: SelectSubset<T, SpeakingSessionFindFirstArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpeakingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSessionFindFirstOrThrowArgs} args - Arguments to find a SpeakingSession
     * @example
     * // Get one SpeakingSession
     * const speakingSession = await prisma.speakingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpeakingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeakingSessions
     * const speakingSessions = await prisma.speakingSession.findMany()
     * 
     * // Get first 10 SpeakingSessions
     * const speakingSessions = await prisma.speakingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakingSessionWithIdOnly = await prisma.speakingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakingSessionFindManyArgs>(args?: SelectSubset<T, SpeakingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpeakingSession.
     * @param {SpeakingSessionCreateArgs} args - Arguments to create a SpeakingSession.
     * @example
     * // Create one SpeakingSession
     * const SpeakingSession = await prisma.speakingSession.create({
     *   data: {
     *     // ... data to create a SpeakingSession
     *   }
     * })
     * 
     */
    create<T extends SpeakingSessionCreateArgs>(args: SelectSubset<T, SpeakingSessionCreateArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpeakingSessions.
     * @param {SpeakingSessionCreateManyArgs} args - Arguments to create many SpeakingSessions.
     * @example
     * // Create many SpeakingSessions
     * const speakingSession = await prisma.speakingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakingSessionCreateManyArgs>(args?: SelectSubset<T, SpeakingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeakingSessions and returns the data saved in the database.
     * @param {SpeakingSessionCreateManyAndReturnArgs} args - Arguments to create many SpeakingSessions.
     * @example
     * // Create many SpeakingSessions
     * const speakingSession = await prisma.speakingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeakingSessions and only return the `id`
     * const speakingSessionWithIdOnly = await prisma.speakingSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeakingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeakingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpeakingSession.
     * @param {SpeakingSessionDeleteArgs} args - Arguments to delete one SpeakingSession.
     * @example
     * // Delete one SpeakingSession
     * const SpeakingSession = await prisma.speakingSession.delete({
     *   where: {
     *     // ... filter to delete one SpeakingSession
     *   }
     * })
     * 
     */
    delete<T extends SpeakingSessionDeleteArgs>(args: SelectSubset<T, SpeakingSessionDeleteArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpeakingSession.
     * @param {SpeakingSessionUpdateArgs} args - Arguments to update one SpeakingSession.
     * @example
     * // Update one SpeakingSession
     * const speakingSession = await prisma.speakingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakingSessionUpdateArgs>(args: SelectSubset<T, SpeakingSessionUpdateArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpeakingSessions.
     * @param {SpeakingSessionDeleteManyArgs} args - Arguments to filter SpeakingSessions to delete.
     * @example
     * // Delete a few SpeakingSessions
     * const { count } = await prisma.speakingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakingSessionDeleteManyArgs>(args?: SelectSubset<T, SpeakingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeakingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeakingSessions
     * const speakingSession = await prisma.speakingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakingSessionUpdateManyArgs>(args: SelectSubset<T, SpeakingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpeakingSession.
     * @param {SpeakingSessionUpsertArgs} args - Arguments to update or create a SpeakingSession.
     * @example
     * // Update or create a SpeakingSession
     * const speakingSession = await prisma.speakingSession.upsert({
     *   create: {
     *     // ... data to create a SpeakingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeakingSession we want to update
     *   }
     * })
     */
    upsert<T extends SpeakingSessionUpsertArgs>(args: SelectSubset<T, SpeakingSessionUpsertArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpeakingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSessionCountArgs} args - Arguments to filter SpeakingSessions to count.
     * @example
     * // Count the number of SpeakingSessions
     * const count = await prisma.speakingSession.count({
     *   where: {
     *     // ... the filter for the SpeakingSessions we want to count
     *   }
     * })
    **/
    count<T extends SpeakingSessionCountArgs>(
      args?: Subset<T, SpeakingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeakingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakingSessionAggregateArgs>(args: Subset<T, SpeakingSessionAggregateArgs>): Prisma.PrismaPromise<GetSpeakingSessionAggregateType<T>>

    /**
     * Group by SpeakingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakingSessionGroupByArgs['orderBy'] }
        : { orderBy?: SpeakingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeakingSession model
   */
  readonly fields: SpeakingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeakingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attempts<T extends SpeakingSession$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, SpeakingSession$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeakingSession model
   */ 
  interface SpeakingSessionFieldRefs {
    readonly id: FieldRef<"SpeakingSession", 'String'>
    readonly userId: FieldRef<"SpeakingSession", 'String'>
    readonly bestScore: FieldRef<"SpeakingSession", 'Int'>
    readonly startedAt: FieldRef<"SpeakingSession", 'DateTime'>
    readonly completedAt: FieldRef<"SpeakingSession", 'DateTime'>
    readonly totalTime: FieldRef<"SpeakingSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpeakingSession findUnique
   */
  export type SpeakingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSession to fetch.
     */
    where: SpeakingSessionWhereUniqueInput
  }

  /**
   * SpeakingSession findUniqueOrThrow
   */
  export type SpeakingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSession to fetch.
     */
    where: SpeakingSessionWhereUniqueInput
  }

  /**
   * SpeakingSession findFirst
   */
  export type SpeakingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSession to fetch.
     */
    where?: SpeakingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSessions to fetch.
     */
    orderBy?: SpeakingSessionOrderByWithRelationInput | SpeakingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingSessions.
     */
    cursor?: SpeakingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingSessions.
     */
    distinct?: SpeakingSessionScalarFieldEnum | SpeakingSessionScalarFieldEnum[]
  }

  /**
   * SpeakingSession findFirstOrThrow
   */
  export type SpeakingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSession to fetch.
     */
    where?: SpeakingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSessions to fetch.
     */
    orderBy?: SpeakingSessionOrderByWithRelationInput | SpeakingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingSessions.
     */
    cursor?: SpeakingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingSessions.
     */
    distinct?: SpeakingSessionScalarFieldEnum | SpeakingSessionScalarFieldEnum[]
  }

  /**
   * SpeakingSession findMany
   */
  export type SpeakingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingSessions to fetch.
     */
    where?: SpeakingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingSessions to fetch.
     */
    orderBy?: SpeakingSessionOrderByWithRelationInput | SpeakingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeakingSessions.
     */
    cursor?: SpeakingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingSessions.
     */
    skip?: number
    distinct?: SpeakingSessionScalarFieldEnum | SpeakingSessionScalarFieldEnum[]
  }

  /**
   * SpeakingSession create
   */
  export type SpeakingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SpeakingSession.
     */
    data: XOR<SpeakingSessionCreateInput, SpeakingSessionUncheckedCreateInput>
  }

  /**
   * SpeakingSession createMany
   */
  export type SpeakingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeakingSessions.
     */
    data: SpeakingSessionCreateManyInput | SpeakingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpeakingSession createManyAndReturn
   */
  export type SpeakingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpeakingSessions.
     */
    data: SpeakingSessionCreateManyInput | SpeakingSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeakingSession update
   */
  export type SpeakingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SpeakingSession.
     */
    data: XOR<SpeakingSessionUpdateInput, SpeakingSessionUncheckedUpdateInput>
    /**
     * Choose, which SpeakingSession to update.
     */
    where: SpeakingSessionWhereUniqueInput
  }

  /**
   * SpeakingSession updateMany
   */
  export type SpeakingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeakingSessions.
     */
    data: XOR<SpeakingSessionUpdateManyMutationInput, SpeakingSessionUncheckedUpdateManyInput>
    /**
     * Filter which SpeakingSessions to update
     */
    where?: SpeakingSessionWhereInput
  }

  /**
   * SpeakingSession upsert
   */
  export type SpeakingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SpeakingSession to update in case it exists.
     */
    where: SpeakingSessionWhereUniqueInput
    /**
     * In case the SpeakingSession found by the `where` argument doesn't exist, create a new SpeakingSession with this data.
     */
    create: XOR<SpeakingSessionCreateInput, SpeakingSessionUncheckedCreateInput>
    /**
     * In case the SpeakingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakingSessionUpdateInput, SpeakingSessionUncheckedUpdateInput>
  }

  /**
   * SpeakingSession delete
   */
  export type SpeakingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
    /**
     * Filter which SpeakingSession to delete.
     */
    where: SpeakingSessionWhereUniqueInput
  }

  /**
   * SpeakingSession deleteMany
   */
  export type SpeakingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingSessions to delete
     */
    where?: SpeakingSessionWhereInput
  }

  /**
   * SpeakingSession.attempts
   */
  export type SpeakingSession$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    where?: SpeakingAttemptWhereInput
    orderBy?: SpeakingAttemptOrderByWithRelationInput | SpeakingAttemptOrderByWithRelationInput[]
    cursor?: SpeakingAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeakingAttemptScalarFieldEnum | SpeakingAttemptScalarFieldEnum[]
  }

  /**
   * SpeakingSession without action
   */
  export type SpeakingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingSession
     */
    select?: SpeakingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingSessionInclude<ExtArgs> | null
  }


  /**
   * Model SpeakingAttempt
   */

  export type AggregateSpeakingAttempt = {
    _count: SpeakingAttemptCountAggregateOutputType | null
    _avg: SpeakingAttemptAvgAggregateOutputType | null
    _sum: SpeakingAttemptSumAggregateOutputType | null
    _min: SpeakingAttemptMinAggregateOutputType | null
    _max: SpeakingAttemptMaxAggregateOutputType | null
  }

  export type SpeakingAttemptAvgAggregateOutputType = {
    duration: number | null
    overallScore: number | null
    accuracy: number | null
    fluency: number | null
    completeness: number | null
    prosody: number | null
  }

  export type SpeakingAttemptSumAggregateOutputType = {
    duration: number | null
    overallScore: number | null
    accuracy: number | null
    fluency: number | null
    completeness: number | null
    prosody: number | null
  }

  export type SpeakingAttemptMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phraseId: string | null
    audioUrl: string | null
    duration: number | null
    transcription: string | null
    overallScore: number | null
    accuracy: number | null
    fluency: number | null
    completeness: number | null
    prosody: number | null
    createdAt: Date | null
  }

  export type SpeakingAttemptMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    phraseId: string | null
    audioUrl: string | null
    duration: number | null
    transcription: string | null
    overallScore: number | null
    accuracy: number | null
    fluency: number | null
    completeness: number | null
    prosody: number | null
    createdAt: Date | null
  }

  export type SpeakingAttemptCountAggregateOutputType = {
    id: number
    sessionId: number
    phraseId: number
    audioUrl: number
    duration: number
    transcription: number
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: number
    mistakes: number
    phonemes: number
    createdAt: number
    _all: number
  }


  export type SpeakingAttemptAvgAggregateInputType = {
    duration?: true
    overallScore?: true
    accuracy?: true
    fluency?: true
    completeness?: true
    prosody?: true
  }

  export type SpeakingAttemptSumAggregateInputType = {
    duration?: true
    overallScore?: true
    accuracy?: true
    fluency?: true
    completeness?: true
    prosody?: true
  }

  export type SpeakingAttemptMinAggregateInputType = {
    id?: true
    sessionId?: true
    phraseId?: true
    audioUrl?: true
    duration?: true
    transcription?: true
    overallScore?: true
    accuracy?: true
    fluency?: true
    completeness?: true
    prosody?: true
    createdAt?: true
  }

  export type SpeakingAttemptMaxAggregateInputType = {
    id?: true
    sessionId?: true
    phraseId?: true
    audioUrl?: true
    duration?: true
    transcription?: true
    overallScore?: true
    accuracy?: true
    fluency?: true
    completeness?: true
    prosody?: true
    createdAt?: true
  }

  export type SpeakingAttemptCountAggregateInputType = {
    id?: true
    sessionId?: true
    phraseId?: true
    audioUrl?: true
    duration?: true
    transcription?: true
    overallScore?: true
    accuracy?: true
    fluency?: true
    completeness?: true
    prosody?: true
    feedback?: true
    mistakes?: true
    phonemes?: true
    createdAt?: true
    _all?: true
  }

  export type SpeakingAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingAttempt to aggregate.
     */
    where?: SpeakingAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingAttempts to fetch.
     */
    orderBy?: SpeakingAttemptOrderByWithRelationInput | SpeakingAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakingAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeakingAttempts
    **/
    _count?: true | SpeakingAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeakingAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeakingAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakingAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakingAttemptMaxAggregateInputType
  }

  export type GetSpeakingAttemptAggregateType<T extends SpeakingAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakingAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakingAttempt[P]>
      : GetScalarType<T[P], AggregateSpeakingAttempt[P]>
  }




  export type SpeakingAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakingAttemptWhereInput
    orderBy?: SpeakingAttemptOrderByWithAggregationInput | SpeakingAttemptOrderByWithAggregationInput[]
    by: SpeakingAttemptScalarFieldEnum[] | SpeakingAttemptScalarFieldEnum
    having?: SpeakingAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakingAttemptCountAggregateInputType | true
    _avg?: SpeakingAttemptAvgAggregateInputType
    _sum?: SpeakingAttemptSumAggregateInputType
    _min?: SpeakingAttemptMinAggregateInputType
    _max?: SpeakingAttemptMaxAggregateInputType
  }

  export type SpeakingAttemptGroupByOutputType = {
    id: string
    sessionId: string
    phraseId: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonValue
    mistakes: JsonValue
    phonemes: JsonValue
    createdAt: Date
    _count: SpeakingAttemptCountAggregateOutputType | null
    _avg: SpeakingAttemptAvgAggregateOutputType | null
    _sum: SpeakingAttemptSumAggregateOutputType | null
    _min: SpeakingAttemptMinAggregateOutputType | null
    _max: SpeakingAttemptMaxAggregateOutputType | null
  }

  type GetSpeakingAttemptGroupByPayload<T extends SpeakingAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakingAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakingAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakingAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakingAttemptGroupByOutputType[P]>
        }
      >
    >


  export type SpeakingAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phraseId?: boolean
    audioUrl?: boolean
    duration?: boolean
    transcription?: boolean
    overallScore?: boolean
    accuracy?: boolean
    fluency?: boolean
    completeness?: boolean
    prosody?: boolean
    feedback?: boolean
    mistakes?: boolean
    phonemes?: boolean
    createdAt?: boolean
    session?: boolean | SpeakingSessionDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakingAttempt"]>

  export type SpeakingAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    phraseId?: boolean
    audioUrl?: boolean
    duration?: boolean
    transcription?: boolean
    overallScore?: boolean
    accuracy?: boolean
    fluency?: boolean
    completeness?: boolean
    prosody?: boolean
    feedback?: boolean
    mistakes?: boolean
    phonemes?: boolean
    createdAt?: boolean
    session?: boolean | SpeakingSessionDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakingAttempt"]>

  export type SpeakingAttemptSelectScalar = {
    id?: boolean
    sessionId?: boolean
    phraseId?: boolean
    audioUrl?: boolean
    duration?: boolean
    transcription?: boolean
    overallScore?: boolean
    accuracy?: boolean
    fluency?: boolean
    completeness?: boolean
    prosody?: boolean
    feedback?: boolean
    mistakes?: boolean
    phonemes?: boolean
    createdAt?: boolean
  }

  export type SpeakingAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SpeakingSessionDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }
  export type SpeakingAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SpeakingSessionDefaultArgs<ExtArgs>
    phrase?: boolean | PhraseDefaultArgs<ExtArgs>
  }

  export type $SpeakingAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeakingAttempt"
    objects: {
      session: Prisma.$SpeakingSessionPayload<ExtArgs>
      phrase: Prisma.$PhrasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      phraseId: string
      audioUrl: string
      duration: number
      transcription: string
      overallScore: number
      accuracy: number
      fluency: number
      completeness: number
      prosody: number
      feedback: Prisma.JsonValue
      mistakes: Prisma.JsonValue
      phonemes: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["speakingAttempt"]>
    composites: {}
  }

  type SpeakingAttemptGetPayload<S extends boolean | null | undefined | SpeakingAttemptDefaultArgs> = $Result.GetResult<Prisma.$SpeakingAttemptPayload, S>

  type SpeakingAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpeakingAttemptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpeakingAttemptCountAggregateInputType | true
    }

  export interface SpeakingAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeakingAttempt'], meta: { name: 'SpeakingAttempt' } }
    /**
     * Find zero or one SpeakingAttempt that matches the filter.
     * @param {SpeakingAttemptFindUniqueArgs} args - Arguments to find a SpeakingAttempt
     * @example
     * // Get one SpeakingAttempt
     * const speakingAttempt = await prisma.speakingAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakingAttemptFindUniqueArgs>(args: SelectSubset<T, SpeakingAttemptFindUniqueArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpeakingAttempt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpeakingAttemptFindUniqueOrThrowArgs} args - Arguments to find a SpeakingAttempt
     * @example
     * // Get one SpeakingAttempt
     * const speakingAttempt = await prisma.speakingAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakingAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakingAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpeakingAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingAttemptFindFirstArgs} args - Arguments to find a SpeakingAttempt
     * @example
     * // Get one SpeakingAttempt
     * const speakingAttempt = await prisma.speakingAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakingAttemptFindFirstArgs>(args?: SelectSubset<T, SpeakingAttemptFindFirstArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpeakingAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingAttemptFindFirstOrThrowArgs} args - Arguments to find a SpeakingAttempt
     * @example
     * // Get one SpeakingAttempt
     * const speakingAttempt = await prisma.speakingAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakingAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakingAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpeakingAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeakingAttempts
     * const speakingAttempts = await prisma.speakingAttempt.findMany()
     * 
     * // Get first 10 SpeakingAttempts
     * const speakingAttempts = await prisma.speakingAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakingAttemptWithIdOnly = await prisma.speakingAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakingAttemptFindManyArgs>(args?: SelectSubset<T, SpeakingAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpeakingAttempt.
     * @param {SpeakingAttemptCreateArgs} args - Arguments to create a SpeakingAttempt.
     * @example
     * // Create one SpeakingAttempt
     * const SpeakingAttempt = await prisma.speakingAttempt.create({
     *   data: {
     *     // ... data to create a SpeakingAttempt
     *   }
     * })
     * 
     */
    create<T extends SpeakingAttemptCreateArgs>(args: SelectSubset<T, SpeakingAttemptCreateArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpeakingAttempts.
     * @param {SpeakingAttemptCreateManyArgs} args - Arguments to create many SpeakingAttempts.
     * @example
     * // Create many SpeakingAttempts
     * const speakingAttempt = await prisma.speakingAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakingAttemptCreateManyArgs>(args?: SelectSubset<T, SpeakingAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeakingAttempts and returns the data saved in the database.
     * @param {SpeakingAttemptCreateManyAndReturnArgs} args - Arguments to create many SpeakingAttempts.
     * @example
     * // Create many SpeakingAttempts
     * const speakingAttempt = await prisma.speakingAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeakingAttempts and only return the `id`
     * const speakingAttemptWithIdOnly = await prisma.speakingAttempt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeakingAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeakingAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpeakingAttempt.
     * @param {SpeakingAttemptDeleteArgs} args - Arguments to delete one SpeakingAttempt.
     * @example
     * // Delete one SpeakingAttempt
     * const SpeakingAttempt = await prisma.speakingAttempt.delete({
     *   where: {
     *     // ... filter to delete one SpeakingAttempt
     *   }
     * })
     * 
     */
    delete<T extends SpeakingAttemptDeleteArgs>(args: SelectSubset<T, SpeakingAttemptDeleteArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpeakingAttempt.
     * @param {SpeakingAttemptUpdateArgs} args - Arguments to update one SpeakingAttempt.
     * @example
     * // Update one SpeakingAttempt
     * const speakingAttempt = await prisma.speakingAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakingAttemptUpdateArgs>(args: SelectSubset<T, SpeakingAttemptUpdateArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpeakingAttempts.
     * @param {SpeakingAttemptDeleteManyArgs} args - Arguments to filter SpeakingAttempts to delete.
     * @example
     * // Delete a few SpeakingAttempts
     * const { count } = await prisma.speakingAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakingAttemptDeleteManyArgs>(args?: SelectSubset<T, SpeakingAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeakingAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeakingAttempts
     * const speakingAttempt = await prisma.speakingAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakingAttemptUpdateManyArgs>(args: SelectSubset<T, SpeakingAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpeakingAttempt.
     * @param {SpeakingAttemptUpsertArgs} args - Arguments to update or create a SpeakingAttempt.
     * @example
     * // Update or create a SpeakingAttempt
     * const speakingAttempt = await prisma.speakingAttempt.upsert({
     *   create: {
     *     // ... data to create a SpeakingAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeakingAttempt we want to update
     *   }
     * })
     */
    upsert<T extends SpeakingAttemptUpsertArgs>(args: SelectSubset<T, SpeakingAttemptUpsertArgs<ExtArgs>>): Prisma__SpeakingAttemptClient<$Result.GetResult<Prisma.$SpeakingAttemptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpeakingAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingAttemptCountArgs} args - Arguments to filter SpeakingAttempts to count.
     * @example
     * // Count the number of SpeakingAttempts
     * const count = await prisma.speakingAttempt.count({
     *   where: {
     *     // ... the filter for the SpeakingAttempts we want to count
     *   }
     * })
    **/
    count<T extends SpeakingAttemptCountArgs>(
      args?: Subset<T, SpeakingAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakingAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeakingAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakingAttemptAggregateArgs>(args: Subset<T, SpeakingAttemptAggregateArgs>): Prisma.PrismaPromise<GetSpeakingAttemptAggregateType<T>>

    /**
     * Group by SpeakingAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakingAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakingAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakingAttemptGroupByArgs['orderBy'] }
        : { orderBy?: SpeakingAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakingAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakingAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeakingAttempt model
   */
  readonly fields: SpeakingAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeakingAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakingAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SpeakingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpeakingSessionDefaultArgs<ExtArgs>>): Prisma__SpeakingSessionClient<$Result.GetResult<Prisma.$SpeakingSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    phrase<T extends PhraseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhraseDefaultArgs<ExtArgs>>): Prisma__PhraseClient<$Result.GetResult<Prisma.$PhrasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeakingAttempt model
   */ 
  interface SpeakingAttemptFieldRefs {
    readonly id: FieldRef<"SpeakingAttempt", 'String'>
    readonly sessionId: FieldRef<"SpeakingAttempt", 'String'>
    readonly phraseId: FieldRef<"SpeakingAttempt", 'String'>
    readonly audioUrl: FieldRef<"SpeakingAttempt", 'String'>
    readonly duration: FieldRef<"SpeakingAttempt", 'Int'>
    readonly transcription: FieldRef<"SpeakingAttempt", 'String'>
    readonly overallScore: FieldRef<"SpeakingAttempt", 'Int'>
    readonly accuracy: FieldRef<"SpeakingAttempt", 'Int'>
    readonly fluency: FieldRef<"SpeakingAttempt", 'Int'>
    readonly completeness: FieldRef<"SpeakingAttempt", 'Int'>
    readonly prosody: FieldRef<"SpeakingAttempt", 'Int'>
    readonly feedback: FieldRef<"SpeakingAttempt", 'Json'>
    readonly mistakes: FieldRef<"SpeakingAttempt", 'Json'>
    readonly phonemes: FieldRef<"SpeakingAttempt", 'Json'>
    readonly createdAt: FieldRef<"SpeakingAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SpeakingAttempt findUnique
   */
  export type SpeakingAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingAttempt to fetch.
     */
    where: SpeakingAttemptWhereUniqueInput
  }

  /**
   * SpeakingAttempt findUniqueOrThrow
   */
  export type SpeakingAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingAttempt to fetch.
     */
    where: SpeakingAttemptWhereUniqueInput
  }

  /**
   * SpeakingAttempt findFirst
   */
  export type SpeakingAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingAttempt to fetch.
     */
    where?: SpeakingAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingAttempts to fetch.
     */
    orderBy?: SpeakingAttemptOrderByWithRelationInput | SpeakingAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingAttempts.
     */
    cursor?: SpeakingAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingAttempts.
     */
    distinct?: SpeakingAttemptScalarFieldEnum | SpeakingAttemptScalarFieldEnum[]
  }

  /**
   * SpeakingAttempt findFirstOrThrow
   */
  export type SpeakingAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingAttempt to fetch.
     */
    where?: SpeakingAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingAttempts to fetch.
     */
    orderBy?: SpeakingAttemptOrderByWithRelationInput | SpeakingAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakingAttempts.
     */
    cursor?: SpeakingAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakingAttempts.
     */
    distinct?: SpeakingAttemptScalarFieldEnum | SpeakingAttemptScalarFieldEnum[]
  }

  /**
   * SpeakingAttempt findMany
   */
  export type SpeakingAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * Filter, which SpeakingAttempts to fetch.
     */
    where?: SpeakingAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakingAttempts to fetch.
     */
    orderBy?: SpeakingAttemptOrderByWithRelationInput | SpeakingAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeakingAttempts.
     */
    cursor?: SpeakingAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakingAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakingAttempts.
     */
    skip?: number
    distinct?: SpeakingAttemptScalarFieldEnum | SpeakingAttemptScalarFieldEnum[]
  }

  /**
   * SpeakingAttempt create
   */
  export type SpeakingAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a SpeakingAttempt.
     */
    data: XOR<SpeakingAttemptCreateInput, SpeakingAttemptUncheckedCreateInput>
  }

  /**
   * SpeakingAttempt createMany
   */
  export type SpeakingAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeakingAttempts.
     */
    data: SpeakingAttemptCreateManyInput | SpeakingAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpeakingAttempt createManyAndReturn
   */
  export type SpeakingAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpeakingAttempts.
     */
    data: SpeakingAttemptCreateManyInput | SpeakingAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeakingAttempt update
   */
  export type SpeakingAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a SpeakingAttempt.
     */
    data: XOR<SpeakingAttemptUpdateInput, SpeakingAttemptUncheckedUpdateInput>
    /**
     * Choose, which SpeakingAttempt to update.
     */
    where: SpeakingAttemptWhereUniqueInput
  }

  /**
   * SpeakingAttempt updateMany
   */
  export type SpeakingAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeakingAttempts.
     */
    data: XOR<SpeakingAttemptUpdateManyMutationInput, SpeakingAttemptUncheckedUpdateManyInput>
    /**
     * Filter which SpeakingAttempts to update
     */
    where?: SpeakingAttemptWhereInput
  }

  /**
   * SpeakingAttempt upsert
   */
  export type SpeakingAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the SpeakingAttempt to update in case it exists.
     */
    where: SpeakingAttemptWhereUniqueInput
    /**
     * In case the SpeakingAttempt found by the `where` argument doesn't exist, create a new SpeakingAttempt with this data.
     */
    create: XOR<SpeakingAttemptCreateInput, SpeakingAttemptUncheckedCreateInput>
    /**
     * In case the SpeakingAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakingAttemptUpdateInput, SpeakingAttemptUncheckedUpdateInput>
  }

  /**
   * SpeakingAttempt delete
   */
  export type SpeakingAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
    /**
     * Filter which SpeakingAttempt to delete.
     */
    where: SpeakingAttemptWhereUniqueInput
  }

  /**
   * SpeakingAttempt deleteMany
   */
  export type SpeakingAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakingAttempts to delete
     */
    where?: SpeakingAttemptWhereInput
  }

  /**
   * SpeakingAttempt without action
   */
  export type SpeakingAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakingAttempt
     */
    select?: SpeakingAttemptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakingAttemptInclude<ExtArgs> | null
  }


  /**
   * Model ListeningSession
   */

  export type AggregateListeningSession = {
    _count: ListeningSessionCountAggregateOutputType | null
    _avg: ListeningSessionAvgAggregateOutputType | null
    _sum: ListeningSessionSumAggregateOutputType | null
    _min: ListeningSessionMinAggregateOutputType | null
    _max: ListeningSessionMaxAggregateOutputType | null
  }

  export type ListeningSessionAvgAggregateOutputType = {
    speed: number | null
    score: number | null
    timeSpent: number | null
  }

  export type ListeningSessionSumAggregateOutputType = {
    speed: number | null
    score: number | null
    timeSpent: number | null
  }

  export type ListeningSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseType: string | null
    accent: string | null
    speed: number | null
    score: number | null
    timeSpent: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ListeningSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    exerciseType: string | null
    accent: string | null
    speed: number | null
    score: number | null
    timeSpent: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type ListeningSessionCountAggregateOutputType = {
    id: number
    userId: number
    exerciseType: number
    accent: number
    speed: number
    exercises: number
    answers: number
    score: number
    timeSpent: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type ListeningSessionAvgAggregateInputType = {
    speed?: true
    score?: true
    timeSpent?: true
  }

  export type ListeningSessionSumAggregateInputType = {
    speed?: true
    score?: true
    timeSpent?: true
  }

  export type ListeningSessionMinAggregateInputType = {
    id?: true
    userId?: true
    exerciseType?: true
    accent?: true
    speed?: true
    score?: true
    timeSpent?: true
    completedAt?: true
    createdAt?: true
  }

  export type ListeningSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    exerciseType?: true
    accent?: true
    speed?: true
    score?: true
    timeSpent?: true
    completedAt?: true
    createdAt?: true
  }

  export type ListeningSessionCountAggregateInputType = {
    id?: true
    userId?: true
    exerciseType?: true
    accent?: true
    speed?: true
    exercises?: true
    answers?: true
    score?: true
    timeSpent?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ListeningSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningSession to aggregate.
     */
    where?: ListeningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningSessions to fetch.
     */
    orderBy?: ListeningSessionOrderByWithRelationInput | ListeningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListeningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ListeningSessions
    **/
    _count?: true | ListeningSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListeningSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListeningSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListeningSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListeningSessionMaxAggregateInputType
  }

  export type GetListeningSessionAggregateType<T extends ListeningSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateListeningSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListeningSession[P]>
      : GetScalarType<T[P], AggregateListeningSession[P]>
  }




  export type ListeningSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListeningSessionWhereInput
    orderBy?: ListeningSessionOrderByWithAggregationInput | ListeningSessionOrderByWithAggregationInput[]
    by: ListeningSessionScalarFieldEnum[] | ListeningSessionScalarFieldEnum
    having?: ListeningSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListeningSessionCountAggregateInputType | true
    _avg?: ListeningSessionAvgAggregateInputType
    _sum?: ListeningSessionSumAggregateInputType
    _min?: ListeningSessionMinAggregateInputType
    _max?: ListeningSessionMaxAggregateInputType
  }

  export type ListeningSessionGroupByOutputType = {
    id: string
    userId: string
    exerciseType: string
    accent: string
    speed: number
    exercises: JsonValue
    answers: JsonValue
    score: number
    timeSpent: number
    completedAt: Date | null
    createdAt: Date
    _count: ListeningSessionCountAggregateOutputType | null
    _avg: ListeningSessionAvgAggregateOutputType | null
    _sum: ListeningSessionSumAggregateOutputType | null
    _min: ListeningSessionMinAggregateOutputType | null
    _max: ListeningSessionMaxAggregateOutputType | null
  }

  type GetListeningSessionGroupByPayload<T extends ListeningSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListeningSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListeningSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListeningSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ListeningSessionGroupByOutputType[P]>
        }
      >
    >


  export type ListeningSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseType?: boolean
    accent?: boolean
    speed?: boolean
    exercises?: boolean
    answers?: boolean
    score?: boolean
    timeSpent?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningSession"]>

  export type ListeningSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    exerciseType?: boolean
    accent?: boolean
    speed?: boolean
    exercises?: boolean
    answers?: boolean
    score?: boolean
    timeSpent?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listeningSession"]>

  export type ListeningSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    exerciseType?: boolean
    accent?: boolean
    speed?: boolean
    exercises?: boolean
    answers?: boolean
    score?: boolean
    timeSpent?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type ListeningSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ListeningSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ListeningSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ListeningSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      exerciseType: string
      accent: string
      speed: number
      exercises: Prisma.JsonValue
      answers: Prisma.JsonValue
      score: number
      timeSpent: number
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["listeningSession"]>
    composites: {}
  }

  type ListeningSessionGetPayload<S extends boolean | null | undefined | ListeningSessionDefaultArgs> = $Result.GetResult<Prisma.$ListeningSessionPayload, S>

  type ListeningSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ListeningSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ListeningSessionCountAggregateInputType | true
    }

  export interface ListeningSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ListeningSession'], meta: { name: 'ListeningSession' } }
    /**
     * Find zero or one ListeningSession that matches the filter.
     * @param {ListeningSessionFindUniqueArgs} args - Arguments to find a ListeningSession
     * @example
     * // Get one ListeningSession
     * const listeningSession = await prisma.listeningSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListeningSessionFindUniqueArgs>(args: SelectSubset<T, ListeningSessionFindUniqueArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ListeningSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ListeningSessionFindUniqueOrThrowArgs} args - Arguments to find a ListeningSession
     * @example
     * // Get one ListeningSession
     * const listeningSession = await prisma.listeningSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListeningSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ListeningSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ListeningSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningSessionFindFirstArgs} args - Arguments to find a ListeningSession
     * @example
     * // Get one ListeningSession
     * const listeningSession = await prisma.listeningSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListeningSessionFindFirstArgs>(args?: SelectSubset<T, ListeningSessionFindFirstArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ListeningSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningSessionFindFirstOrThrowArgs} args - Arguments to find a ListeningSession
     * @example
     * // Get one ListeningSession
     * const listeningSession = await prisma.listeningSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListeningSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ListeningSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ListeningSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ListeningSessions
     * const listeningSessions = await prisma.listeningSession.findMany()
     * 
     * // Get first 10 ListeningSessions
     * const listeningSessions = await prisma.listeningSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listeningSessionWithIdOnly = await prisma.listeningSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListeningSessionFindManyArgs>(args?: SelectSubset<T, ListeningSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ListeningSession.
     * @param {ListeningSessionCreateArgs} args - Arguments to create a ListeningSession.
     * @example
     * // Create one ListeningSession
     * const ListeningSession = await prisma.listeningSession.create({
     *   data: {
     *     // ... data to create a ListeningSession
     *   }
     * })
     * 
     */
    create<T extends ListeningSessionCreateArgs>(args: SelectSubset<T, ListeningSessionCreateArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ListeningSessions.
     * @param {ListeningSessionCreateManyArgs} args - Arguments to create many ListeningSessions.
     * @example
     * // Create many ListeningSessions
     * const listeningSession = await prisma.listeningSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListeningSessionCreateManyArgs>(args?: SelectSubset<T, ListeningSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ListeningSessions and returns the data saved in the database.
     * @param {ListeningSessionCreateManyAndReturnArgs} args - Arguments to create many ListeningSessions.
     * @example
     * // Create many ListeningSessions
     * const listeningSession = await prisma.listeningSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ListeningSessions and only return the `id`
     * const listeningSessionWithIdOnly = await prisma.listeningSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListeningSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ListeningSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ListeningSession.
     * @param {ListeningSessionDeleteArgs} args - Arguments to delete one ListeningSession.
     * @example
     * // Delete one ListeningSession
     * const ListeningSession = await prisma.listeningSession.delete({
     *   where: {
     *     // ... filter to delete one ListeningSession
     *   }
     * })
     * 
     */
    delete<T extends ListeningSessionDeleteArgs>(args: SelectSubset<T, ListeningSessionDeleteArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ListeningSession.
     * @param {ListeningSessionUpdateArgs} args - Arguments to update one ListeningSession.
     * @example
     * // Update one ListeningSession
     * const listeningSession = await prisma.listeningSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListeningSessionUpdateArgs>(args: SelectSubset<T, ListeningSessionUpdateArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ListeningSessions.
     * @param {ListeningSessionDeleteManyArgs} args - Arguments to filter ListeningSessions to delete.
     * @example
     * // Delete a few ListeningSessions
     * const { count } = await prisma.listeningSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListeningSessionDeleteManyArgs>(args?: SelectSubset<T, ListeningSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ListeningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ListeningSessions
     * const listeningSession = await prisma.listeningSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListeningSessionUpdateManyArgs>(args: SelectSubset<T, ListeningSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ListeningSession.
     * @param {ListeningSessionUpsertArgs} args - Arguments to update or create a ListeningSession.
     * @example
     * // Update or create a ListeningSession
     * const listeningSession = await prisma.listeningSession.upsert({
     *   create: {
     *     // ... data to create a ListeningSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ListeningSession we want to update
     *   }
     * })
     */
    upsert<T extends ListeningSessionUpsertArgs>(args: SelectSubset<T, ListeningSessionUpsertArgs<ExtArgs>>): Prisma__ListeningSessionClient<$Result.GetResult<Prisma.$ListeningSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ListeningSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningSessionCountArgs} args - Arguments to filter ListeningSessions to count.
     * @example
     * // Count the number of ListeningSessions
     * const count = await prisma.listeningSession.count({
     *   where: {
     *     // ... the filter for the ListeningSessions we want to count
     *   }
     * })
    **/
    count<T extends ListeningSessionCountArgs>(
      args?: Subset<T, ListeningSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListeningSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ListeningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListeningSessionAggregateArgs>(args: Subset<T, ListeningSessionAggregateArgs>): Prisma.PrismaPromise<GetListeningSessionAggregateType<T>>

    /**
     * Group by ListeningSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListeningSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListeningSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListeningSessionGroupByArgs['orderBy'] }
        : { orderBy?: ListeningSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListeningSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListeningSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ListeningSession model
   */
  readonly fields: ListeningSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ListeningSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListeningSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ListeningSession model
   */ 
  interface ListeningSessionFieldRefs {
    readonly id: FieldRef<"ListeningSession", 'String'>
    readonly userId: FieldRef<"ListeningSession", 'String'>
    readonly exerciseType: FieldRef<"ListeningSession", 'String'>
    readonly accent: FieldRef<"ListeningSession", 'String'>
    readonly speed: FieldRef<"ListeningSession", 'Float'>
    readonly exercises: FieldRef<"ListeningSession", 'Json'>
    readonly answers: FieldRef<"ListeningSession", 'Json'>
    readonly score: FieldRef<"ListeningSession", 'Int'>
    readonly timeSpent: FieldRef<"ListeningSession", 'Int'>
    readonly completedAt: FieldRef<"ListeningSession", 'DateTime'>
    readonly createdAt: FieldRef<"ListeningSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ListeningSession findUnique
   */
  export type ListeningSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningSession to fetch.
     */
    where: ListeningSessionWhereUniqueInput
  }

  /**
   * ListeningSession findUniqueOrThrow
   */
  export type ListeningSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningSession to fetch.
     */
    where: ListeningSessionWhereUniqueInput
  }

  /**
   * ListeningSession findFirst
   */
  export type ListeningSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningSession to fetch.
     */
    where?: ListeningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningSessions to fetch.
     */
    orderBy?: ListeningSessionOrderByWithRelationInput | ListeningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningSessions.
     */
    cursor?: ListeningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningSessions.
     */
    distinct?: ListeningSessionScalarFieldEnum | ListeningSessionScalarFieldEnum[]
  }

  /**
   * ListeningSession findFirstOrThrow
   */
  export type ListeningSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningSession to fetch.
     */
    where?: ListeningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningSessions to fetch.
     */
    orderBy?: ListeningSessionOrderByWithRelationInput | ListeningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ListeningSessions.
     */
    cursor?: ListeningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ListeningSessions.
     */
    distinct?: ListeningSessionScalarFieldEnum | ListeningSessionScalarFieldEnum[]
  }

  /**
   * ListeningSession findMany
   */
  export type ListeningSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * Filter, which ListeningSessions to fetch.
     */
    where?: ListeningSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ListeningSessions to fetch.
     */
    orderBy?: ListeningSessionOrderByWithRelationInput | ListeningSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ListeningSessions.
     */
    cursor?: ListeningSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ListeningSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ListeningSessions.
     */
    skip?: number
    distinct?: ListeningSessionScalarFieldEnum | ListeningSessionScalarFieldEnum[]
  }

  /**
   * ListeningSession create
   */
  export type ListeningSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ListeningSession.
     */
    data: XOR<ListeningSessionCreateInput, ListeningSessionUncheckedCreateInput>
  }

  /**
   * ListeningSession createMany
   */
  export type ListeningSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ListeningSessions.
     */
    data: ListeningSessionCreateManyInput | ListeningSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ListeningSession createManyAndReturn
   */
  export type ListeningSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ListeningSessions.
     */
    data: ListeningSessionCreateManyInput | ListeningSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ListeningSession update
   */
  export type ListeningSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ListeningSession.
     */
    data: XOR<ListeningSessionUpdateInput, ListeningSessionUncheckedUpdateInput>
    /**
     * Choose, which ListeningSession to update.
     */
    where: ListeningSessionWhereUniqueInput
  }

  /**
   * ListeningSession updateMany
   */
  export type ListeningSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ListeningSessions.
     */
    data: XOR<ListeningSessionUpdateManyMutationInput, ListeningSessionUncheckedUpdateManyInput>
    /**
     * Filter which ListeningSessions to update
     */
    where?: ListeningSessionWhereInput
  }

  /**
   * ListeningSession upsert
   */
  export type ListeningSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ListeningSession to update in case it exists.
     */
    where: ListeningSessionWhereUniqueInput
    /**
     * In case the ListeningSession found by the `where` argument doesn't exist, create a new ListeningSession with this data.
     */
    create: XOR<ListeningSessionCreateInput, ListeningSessionUncheckedCreateInput>
    /**
     * In case the ListeningSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListeningSessionUpdateInput, ListeningSessionUncheckedUpdateInput>
  }

  /**
   * ListeningSession delete
   */
  export type ListeningSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
    /**
     * Filter which ListeningSession to delete.
     */
    where: ListeningSessionWhereUniqueInput
  }

  /**
   * ListeningSession deleteMany
   */
  export type ListeningSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ListeningSessions to delete
     */
    where?: ListeningSessionWhereInput
  }

  /**
   * ListeningSession without action
   */
  export type ListeningSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListeningSession
     */
    select?: ListeningSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListeningSessionInclude<ExtArgs> | null
  }


  /**
   * Model PlacementTest
   */

  export type AggregatePlacementTest = {
    _count: PlacementTestCountAggregateOutputType | null
    _avg: PlacementTestAvgAggregateOutputType | null
    _sum: PlacementTestSumAggregateOutputType | null
    _min: PlacementTestMinAggregateOutputType | null
    _max: PlacementTestMaxAggregateOutputType | null
  }

  export type PlacementTestAvgAggregateOutputType = {
    theta: number | null
    standardError: number | null
    score: number | null
  }

  export type PlacementTestSumAggregateOutputType = {
    theta: number | null
    standardError: number | null
    score: number | null
  }

  export type PlacementTestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    theta: number | null
    standardError: number | null
    level: string | null
    score: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type PlacementTestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    theta: number | null
    standardError: number | null
    level: string | null
    score: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type PlacementTestCountAggregateOutputType = {
    id: number
    userId: number
    questions: number
    answers: number
    theta: number
    standardError: number
    level: number
    score: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type PlacementTestAvgAggregateInputType = {
    theta?: true
    standardError?: true
    score?: true
  }

  export type PlacementTestSumAggregateInputType = {
    theta?: true
    standardError?: true
    score?: true
  }

  export type PlacementTestMinAggregateInputType = {
    id?: true
    userId?: true
    theta?: true
    standardError?: true
    level?: true
    score?: true
    completedAt?: true
    createdAt?: true
  }

  export type PlacementTestMaxAggregateInputType = {
    id?: true
    userId?: true
    theta?: true
    standardError?: true
    level?: true
    score?: true
    completedAt?: true
    createdAt?: true
  }

  export type PlacementTestCountAggregateInputType = {
    id?: true
    userId?: true
    questions?: true
    answers?: true
    theta?: true
    standardError?: true
    level?: true
    score?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PlacementTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlacementTest to aggregate.
     */
    where?: PlacementTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementTests to fetch.
     */
    orderBy?: PlacementTestOrderByWithRelationInput | PlacementTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlacementTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlacementTests
    **/
    _count?: true | PlacementTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlacementTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlacementTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlacementTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlacementTestMaxAggregateInputType
  }

  export type GetPlacementTestAggregateType<T extends PlacementTestAggregateArgs> = {
        [P in keyof T & keyof AggregatePlacementTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacementTest[P]>
      : GetScalarType<T[P], AggregatePlacementTest[P]>
  }




  export type PlacementTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementTestWhereInput
    orderBy?: PlacementTestOrderByWithAggregationInput | PlacementTestOrderByWithAggregationInput[]
    by: PlacementTestScalarFieldEnum[] | PlacementTestScalarFieldEnum
    having?: PlacementTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlacementTestCountAggregateInputType | true
    _avg?: PlacementTestAvgAggregateInputType
    _sum?: PlacementTestSumAggregateInputType
    _min?: PlacementTestMinAggregateInputType
    _max?: PlacementTestMaxAggregateInputType
  }

  export type PlacementTestGroupByOutputType = {
    id: string
    userId: string
    questions: JsonValue
    answers: JsonValue
    theta: number
    standardError: number
    level: string
    score: number
    completedAt: Date | null
    createdAt: Date
    _count: PlacementTestCountAggregateOutputType | null
    _avg: PlacementTestAvgAggregateOutputType | null
    _sum: PlacementTestSumAggregateOutputType | null
    _min: PlacementTestMinAggregateOutputType | null
    _max: PlacementTestMaxAggregateOutputType | null
  }

  type GetPlacementTestGroupByPayload<T extends PlacementTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlacementTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlacementTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementTestGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementTestGroupByOutputType[P]>
        }
      >
    >


  export type PlacementTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questions?: boolean
    answers?: boolean
    theta?: boolean
    standardError?: boolean
    level?: boolean
    score?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placementTest"]>

  export type PlacementTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    questions?: boolean
    answers?: boolean
    theta?: boolean
    standardError?: boolean
    level?: boolean
    score?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placementTest"]>

  export type PlacementTestSelectScalar = {
    id?: boolean
    userId?: boolean
    questions?: boolean
    answers?: boolean
    theta?: boolean
    standardError?: boolean
    level?: boolean
    score?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type PlacementTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PlacementTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlacementTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlacementTest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      questions: Prisma.JsonValue
      answers: Prisma.JsonValue
      theta: number
      standardError: number
      level: string
      score: number
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["placementTest"]>
    composites: {}
  }

  type PlacementTestGetPayload<S extends boolean | null | undefined | PlacementTestDefaultArgs> = $Result.GetResult<Prisma.$PlacementTestPayload, S>

  type PlacementTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlacementTestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlacementTestCountAggregateInputType | true
    }

  export interface PlacementTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlacementTest'], meta: { name: 'PlacementTest' } }
    /**
     * Find zero or one PlacementTest that matches the filter.
     * @param {PlacementTestFindUniqueArgs} args - Arguments to find a PlacementTest
     * @example
     * // Get one PlacementTest
     * const placementTest = await prisma.placementTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlacementTestFindUniqueArgs>(args: SelectSubset<T, PlacementTestFindUniqueArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlacementTest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlacementTestFindUniqueOrThrowArgs} args - Arguments to find a PlacementTest
     * @example
     * // Get one PlacementTest
     * const placementTest = await prisma.placementTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlacementTestFindUniqueOrThrowArgs>(args: SelectSubset<T, PlacementTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlacementTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementTestFindFirstArgs} args - Arguments to find a PlacementTest
     * @example
     * // Get one PlacementTest
     * const placementTest = await prisma.placementTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlacementTestFindFirstArgs>(args?: SelectSubset<T, PlacementTestFindFirstArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlacementTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementTestFindFirstOrThrowArgs} args - Arguments to find a PlacementTest
     * @example
     * // Get one PlacementTest
     * const placementTest = await prisma.placementTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlacementTestFindFirstOrThrowArgs>(args?: SelectSubset<T, PlacementTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlacementTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlacementTests
     * const placementTests = await prisma.placementTest.findMany()
     * 
     * // Get first 10 PlacementTests
     * const placementTests = await prisma.placementTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placementTestWithIdOnly = await prisma.placementTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlacementTestFindManyArgs>(args?: SelectSubset<T, PlacementTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlacementTest.
     * @param {PlacementTestCreateArgs} args - Arguments to create a PlacementTest.
     * @example
     * // Create one PlacementTest
     * const PlacementTest = await prisma.placementTest.create({
     *   data: {
     *     // ... data to create a PlacementTest
     *   }
     * })
     * 
     */
    create<T extends PlacementTestCreateArgs>(args: SelectSubset<T, PlacementTestCreateArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlacementTests.
     * @param {PlacementTestCreateManyArgs} args - Arguments to create many PlacementTests.
     * @example
     * // Create many PlacementTests
     * const placementTest = await prisma.placementTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlacementTestCreateManyArgs>(args?: SelectSubset<T, PlacementTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlacementTests and returns the data saved in the database.
     * @param {PlacementTestCreateManyAndReturnArgs} args - Arguments to create many PlacementTests.
     * @example
     * // Create many PlacementTests
     * const placementTest = await prisma.placementTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlacementTests and only return the `id`
     * const placementTestWithIdOnly = await prisma.placementTest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlacementTestCreateManyAndReturnArgs>(args?: SelectSubset<T, PlacementTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlacementTest.
     * @param {PlacementTestDeleteArgs} args - Arguments to delete one PlacementTest.
     * @example
     * // Delete one PlacementTest
     * const PlacementTest = await prisma.placementTest.delete({
     *   where: {
     *     // ... filter to delete one PlacementTest
     *   }
     * })
     * 
     */
    delete<T extends PlacementTestDeleteArgs>(args: SelectSubset<T, PlacementTestDeleteArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlacementTest.
     * @param {PlacementTestUpdateArgs} args - Arguments to update one PlacementTest.
     * @example
     * // Update one PlacementTest
     * const placementTest = await prisma.placementTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlacementTestUpdateArgs>(args: SelectSubset<T, PlacementTestUpdateArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlacementTests.
     * @param {PlacementTestDeleteManyArgs} args - Arguments to filter PlacementTests to delete.
     * @example
     * // Delete a few PlacementTests
     * const { count } = await prisma.placementTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlacementTestDeleteManyArgs>(args?: SelectSubset<T, PlacementTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlacementTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlacementTests
     * const placementTest = await prisma.placementTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlacementTestUpdateManyArgs>(args: SelectSubset<T, PlacementTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlacementTest.
     * @param {PlacementTestUpsertArgs} args - Arguments to update or create a PlacementTest.
     * @example
     * // Update or create a PlacementTest
     * const placementTest = await prisma.placementTest.upsert({
     *   create: {
     *     // ... data to create a PlacementTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlacementTest we want to update
     *   }
     * })
     */
    upsert<T extends PlacementTestUpsertArgs>(args: SelectSubset<T, PlacementTestUpsertArgs<ExtArgs>>): Prisma__PlacementTestClient<$Result.GetResult<Prisma.$PlacementTestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlacementTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementTestCountArgs} args - Arguments to filter PlacementTests to count.
     * @example
     * // Count the number of PlacementTests
     * const count = await prisma.placementTest.count({
     *   where: {
     *     // ... the filter for the PlacementTests we want to count
     *   }
     * })
    **/
    count<T extends PlacementTestCountArgs>(
      args?: Subset<T, PlacementTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlacementTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlacementTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlacementTestAggregateArgs>(args: Subset<T, PlacementTestAggregateArgs>): Prisma.PrismaPromise<GetPlacementTestAggregateType<T>>

    /**
     * Group by PlacementTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlacementTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementTestGroupByArgs['orderBy'] }
        : { orderBy?: PlacementTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlacementTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlacementTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlacementTest model
   */
  readonly fields: PlacementTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlacementTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlacementTest model
   */ 
  interface PlacementTestFieldRefs {
    readonly id: FieldRef<"PlacementTest", 'String'>
    readonly userId: FieldRef<"PlacementTest", 'String'>
    readonly questions: FieldRef<"PlacementTest", 'Json'>
    readonly answers: FieldRef<"PlacementTest", 'Json'>
    readonly theta: FieldRef<"PlacementTest", 'Float'>
    readonly standardError: FieldRef<"PlacementTest", 'Float'>
    readonly level: FieldRef<"PlacementTest", 'String'>
    readonly score: FieldRef<"PlacementTest", 'Int'>
    readonly completedAt: FieldRef<"PlacementTest", 'DateTime'>
    readonly createdAt: FieldRef<"PlacementTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlacementTest findUnique
   */
  export type PlacementTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * Filter, which PlacementTest to fetch.
     */
    where: PlacementTestWhereUniqueInput
  }

  /**
   * PlacementTest findUniqueOrThrow
   */
  export type PlacementTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * Filter, which PlacementTest to fetch.
     */
    where: PlacementTestWhereUniqueInput
  }

  /**
   * PlacementTest findFirst
   */
  export type PlacementTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * Filter, which PlacementTest to fetch.
     */
    where?: PlacementTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementTests to fetch.
     */
    orderBy?: PlacementTestOrderByWithRelationInput | PlacementTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlacementTests.
     */
    cursor?: PlacementTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlacementTests.
     */
    distinct?: PlacementTestScalarFieldEnum | PlacementTestScalarFieldEnum[]
  }

  /**
   * PlacementTest findFirstOrThrow
   */
  export type PlacementTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * Filter, which PlacementTest to fetch.
     */
    where?: PlacementTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementTests to fetch.
     */
    orderBy?: PlacementTestOrderByWithRelationInput | PlacementTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlacementTests.
     */
    cursor?: PlacementTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlacementTests.
     */
    distinct?: PlacementTestScalarFieldEnum | PlacementTestScalarFieldEnum[]
  }

  /**
   * PlacementTest findMany
   */
  export type PlacementTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * Filter, which PlacementTests to fetch.
     */
    where?: PlacementTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlacementTests to fetch.
     */
    orderBy?: PlacementTestOrderByWithRelationInput | PlacementTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlacementTests.
     */
    cursor?: PlacementTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlacementTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlacementTests.
     */
    skip?: number
    distinct?: PlacementTestScalarFieldEnum | PlacementTestScalarFieldEnum[]
  }

  /**
   * PlacementTest create
   */
  export type PlacementTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * The data needed to create a PlacementTest.
     */
    data: XOR<PlacementTestCreateInput, PlacementTestUncheckedCreateInput>
  }

  /**
   * PlacementTest createMany
   */
  export type PlacementTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlacementTests.
     */
    data: PlacementTestCreateManyInput | PlacementTestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlacementTest createManyAndReturn
   */
  export type PlacementTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlacementTests.
     */
    data: PlacementTestCreateManyInput | PlacementTestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlacementTest update
   */
  export type PlacementTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * The data needed to update a PlacementTest.
     */
    data: XOR<PlacementTestUpdateInput, PlacementTestUncheckedUpdateInput>
    /**
     * Choose, which PlacementTest to update.
     */
    where: PlacementTestWhereUniqueInput
  }

  /**
   * PlacementTest updateMany
   */
  export type PlacementTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlacementTests.
     */
    data: XOR<PlacementTestUpdateManyMutationInput, PlacementTestUncheckedUpdateManyInput>
    /**
     * Filter which PlacementTests to update
     */
    where?: PlacementTestWhereInput
  }

  /**
   * PlacementTest upsert
   */
  export type PlacementTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * The filter to search for the PlacementTest to update in case it exists.
     */
    where: PlacementTestWhereUniqueInput
    /**
     * In case the PlacementTest found by the `where` argument doesn't exist, create a new PlacementTest with this data.
     */
    create: XOR<PlacementTestCreateInput, PlacementTestUncheckedCreateInput>
    /**
     * In case the PlacementTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementTestUpdateInput, PlacementTestUncheckedUpdateInput>
  }

  /**
   * PlacementTest delete
   */
  export type PlacementTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
    /**
     * Filter which PlacementTest to delete.
     */
    where: PlacementTestWhereUniqueInput
  }

  /**
   * PlacementTest deleteMany
   */
  export type PlacementTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlacementTests to delete
     */
    where?: PlacementTestWhereInput
  }

  /**
   * PlacementTest without action
   */
  export type PlacementTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementTest
     */
    select?: PlacementTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementTestInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherAvgAggregateOutputType = {
    rating: number | null
    totalLessons: number | null
    experience: number | null
    hourlyRate: number | null
  }

  export type TeacherSumAggregateOutputType = {
    rating: number | null
    totalLessons: number | null
    experience: number | null
    hourlyRate: number | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    avatar: string | null
    bio: string | null
    rating: number | null
    totalLessons: number | null
    experience: number | null
    hourlyRate: number | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    avatar: string | null
    bio: string | null
    rating: number | null
    totalLessons: number | null
    experience: number | null
    hourlyRate: number | null
    timezone: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    name: number
    email: number
    avatar: number
    bio: number
    certifications: number
    specializations: number
    languages: number
    rating: number
    totalLessons: number
    experience: number
    hourlyRate: number
    timezone: number
    availability: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherAvgAggregateInputType = {
    rating?: true
    totalLessons?: true
    experience?: true
    hourlyRate?: true
  }

  export type TeacherSumAggregateInputType = {
    rating?: true
    totalLessons?: true
    experience?: true
    hourlyRate?: true
  }

  export type TeacherMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    avatar?: true
    bio?: true
    rating?: true
    totalLessons?: true
    experience?: true
    hourlyRate?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    avatar?: true
    bio?: true
    rating?: true
    totalLessons?: true
    experience?: true
    hourlyRate?: true
    timezone?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    avatar?: true
    bio?: true
    certifications?: true
    specializations?: true
    languages?: true
    rating?: true
    totalLessons?: true
    experience?: true
    hourlyRate?: true
    timezone?: true
    availability?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeacherAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeacherSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _avg?: TeacherAvgAggregateInputType
    _sum?: TeacherSumAggregateInputType
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    name: string
    email: string
    avatar: string | null
    bio: string | null
    certifications: string[]
    specializations: string[]
    languages: string[]
    rating: number
    totalLessons: number
    experience: number
    hourlyRate: number
    timezone: string
    availability: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TeacherCountAggregateOutputType | null
    _avg: TeacherAvgAggregateOutputType | null
    _sum: TeacherSumAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    avatar?: boolean
    bio?: boolean
    certifications?: boolean
    specializations?: boolean
    languages?: boolean
    rating?: boolean
    totalLessons?: boolean
    experience?: boolean
    hourlyRate?: boolean
    timezone?: boolean
    availability?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lessons?: boolean | Teacher$lessonsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    avatar?: boolean
    bio?: boolean
    certifications?: boolean
    specializations?: boolean
    languages?: boolean
    rating?: boolean
    totalLessons?: boolean
    experience?: boolean
    hourlyRate?: boolean
    timezone?: boolean
    availability?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    avatar?: boolean
    bio?: boolean
    certifications?: boolean
    specializations?: boolean
    languages?: boolean
    rating?: boolean
    totalLessons?: boolean
    experience?: boolean
    hourlyRate?: boolean
    timezone?: boolean
    availability?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | Teacher$lessonsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      avatar: string | null
      bio: string | null
      certifications: string[]
      specializations: string[]
      languages: string[]
      rating: number
      totalLessons: number
      experience: number
      hourlyRate: number
      timezone: string
      availability: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends Teacher$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */ 
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly name: FieldRef<"Teacher", 'String'>
    readonly email: FieldRef<"Teacher", 'String'>
    readonly avatar: FieldRef<"Teacher", 'String'>
    readonly bio: FieldRef<"Teacher", 'String'>
    readonly certifications: FieldRef<"Teacher", 'String[]'>
    readonly specializations: FieldRef<"Teacher", 'String[]'>
    readonly languages: FieldRef<"Teacher", 'String[]'>
    readonly rating: FieldRef<"Teacher", 'Float'>
    readonly totalLessons: FieldRef<"Teacher", 'Int'>
    readonly experience: FieldRef<"Teacher", 'Int'>
    readonly hourlyRate: FieldRef<"Teacher", 'Int'>
    readonly timezone: FieldRef<"Teacher", 'String'>
    readonly availability: FieldRef<"Teacher", 'Json'>
    readonly isActive: FieldRef<"Teacher", 'Boolean'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
    readonly updatedAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
  }

  /**
   * Teacher.lessons
   */
  export type Teacher$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    duration: number | null
    price: number | null
  }

  export type LessonSumAggregateOutputType = {
    duration: number | null
    price: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    teacherId: string | null
    scheduledAt: Date | null
    duration: number | null
    status: string | null
    meetingUrl: string | null
    notes: string | null
    feedback: string | null
    price: number | null
    paid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    teacherId: string | null
    scheduledAt: Date | null
    duration: number | null
    status: string | null
    meetingUrl: string | null
    notes: string | null
    feedback: string | null
    price: number | null
    paid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    studentId: number
    teacherId: number
    scheduledAt: number
    duration: number
    status: number
    meetingUrl: number
    notes: number
    feedback: number
    price: number
    paid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    duration?: true
    price?: true
  }

  export type LessonSumAggregateInputType = {
    duration?: true
    price?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    studentId?: true
    teacherId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    meetingUrl?: true
    notes?: true
    feedback?: true
    price?: true
    paid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    studentId?: true
    teacherId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    meetingUrl?: true
    notes?: true
    feedback?: true
    price?: true
    paid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    studentId?: true
    teacherId?: true
    scheduledAt?: true
    duration?: true
    status?: true
    meetingUrl?: true
    notes?: true
    feedback?: true
    price?: true
    paid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    studentId: string
    teacherId: string
    scheduledAt: Date
    duration: number
    status: string
    meetingUrl: string | null
    notes: string | null
    feedback: string | null
    price: number
    paid: boolean
    createdAt: Date
    updatedAt: Date
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    teacherId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    meetingUrl?: boolean
    notes?: boolean
    feedback?: boolean
    price?: boolean
    paid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    teacherId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    meetingUrl?: boolean
    notes?: boolean
    feedback?: boolean
    price?: boolean
    paid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | UserDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    studentId?: boolean
    teacherId?: boolean
    scheduledAt?: boolean
    duration?: boolean
    status?: boolean
    meetingUrl?: boolean
    notes?: boolean
    feedback?: boolean
    price?: boolean
    paid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | UserDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      student: Prisma.$UserPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      teacherId: string
      scheduledAt: Date
      duration: number
      status: string
      meetingUrl: string | null
      notes: string | null
      feedback: string | null
      price: number
      paid: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */ 
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly studentId: FieldRef<"Lesson", 'String'>
    readonly teacherId: FieldRef<"Lesson", 'String'>
    readonly scheduledAt: FieldRef<"Lesson", 'DateTime'>
    readonly duration: FieldRef<"Lesson", 'Int'>
    readonly status: FieldRef<"Lesson", 'String'>
    readonly meetingUrl: FieldRef<"Lesson", 'String'>
    readonly notes: FieldRef<"Lesson", 'String'>
    readonly feedback: FieldRef<"Lesson", 'String'>
    readonly price: FieldRef<"Lesson", 'Int'>
    readonly paid: FieldRef<"Lesson", 'Boolean'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    stripePaymentIntentId: string | null
    stripeInvoiceId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    stripePaymentIntentId: string | null
    stripeInvoiceId: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    status: number
    stripePaymentIntentId: number
    stripeInvoiceId: number
    description: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentIntentId?: true
    stripeInvoiceId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentIntentId?: true
    stripeInvoiceId?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    stripePaymentIntentId?: true
    stripeInvoiceId?: true
    description?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    amount: number
    currency: string
    status: string
    stripePaymentIntentId: string | null
    stripeInvoiceId: string | null
    description: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    stripeInvoiceId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    stripeInvoiceId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    stripePaymentIntentId?: boolean
    stripeInvoiceId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      currency: string
      status: string
      stripePaymentIntentId: string | null
      stripeInvoiceId: string | null
      description: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly stripeInvoiceId: FieldRef<"Payment", 'String'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    avatar: 'avatar',
    phone: 'phone',
    birthDate: 'birthDate',
    country: 'country',
    timezone: 'timezone',
    level: 'level',
    emailVerified: 'emailVerified',
    refreshToken: 'refreshToken',
    lastLogin: 'lastLogin',
    subscriptionStatus: 'subscriptionStatus',
    subscriptionEndsAt: 'subscriptionEndsAt',
    stripeCustomerId: 'stripeCustomerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const GamificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    xp: 'xp',
    level: 'level',
    xpToNextLevel: 'xpToNextLevel',
    coins: 'coins',
    gems: 'gems',
    streak: 'streak',
    maxStreak: 'maxStreak',
    lastActiveDate: 'lastActiveDate',
    rank: 'rank',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GamificationScalarFieldEnum = (typeof GamificationScalarFieldEnum)[keyof typeof GamificationScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    icon: 'icon',
    category: 'category',
    xpReward: 'xpReward',
    coinsReward: 'coinsReward',
    gemsReward: 'gemsReward',
    requirement: 'requirement',
    isSecret: 'isSecret',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    progress: 'progress',
    unlocked: 'unlocked',
    unlockedAt: 'unlockedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PhraseScalarFieldEnum: {
    id: 'id',
    text: 'text',
    translation: 'translation',
    audioUrl: 'audioUrl',
    imageUrl: 'imageUrl',
    levelId: 'levelId',
    categoryId: 'categoryId',
    difficulty: 'difficulty',
    tags: 'tags',
    ipaTranscription: 'ipaTranscription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PhraseScalarFieldEnum = (typeof PhraseScalarFieldEnum)[keyof typeof PhraseScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    phraseId: 'phraseId',
    mastery: 'mastery',
    attempts: 'attempts',
    successes: 'successes',
    lastScore: 'lastScore',
    bestScore: 'bestScore',
    easeFactor: 'easeFactor',
    interval: 'interval',
    nextReview: 'nextReview',
    lastPracticed: 'lastPracticed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const SpeakingSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bestScore: 'bestScore',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    totalTime: 'totalTime'
  };

  export type SpeakingSessionScalarFieldEnum = (typeof SpeakingSessionScalarFieldEnum)[keyof typeof SpeakingSessionScalarFieldEnum]


  export const SpeakingAttemptScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    phraseId: 'phraseId',
    audioUrl: 'audioUrl',
    duration: 'duration',
    transcription: 'transcription',
    overallScore: 'overallScore',
    accuracy: 'accuracy',
    fluency: 'fluency',
    completeness: 'completeness',
    prosody: 'prosody',
    feedback: 'feedback',
    mistakes: 'mistakes',
    phonemes: 'phonemes',
    createdAt: 'createdAt'
  };

  export type SpeakingAttemptScalarFieldEnum = (typeof SpeakingAttemptScalarFieldEnum)[keyof typeof SpeakingAttemptScalarFieldEnum]


  export const ListeningSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    exerciseType: 'exerciseType',
    accent: 'accent',
    speed: 'speed',
    exercises: 'exercises',
    answers: 'answers',
    score: 'score',
    timeSpent: 'timeSpent',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type ListeningSessionScalarFieldEnum = (typeof ListeningSessionScalarFieldEnum)[keyof typeof ListeningSessionScalarFieldEnum]


  export const PlacementTestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    questions: 'questions',
    answers: 'answers',
    theta: 'theta',
    standardError: 'standardError',
    level: 'level',
    score: 'score',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type PlacementTestScalarFieldEnum = (typeof PlacementTestScalarFieldEnum)[keyof typeof PlacementTestScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    avatar: 'avatar',
    bio: 'bio',
    certifications: 'certifications',
    specializations: 'specializations',
    languages: 'languages',
    rating: 'rating',
    totalLessons: 'totalLessons',
    experience: 'experience',
    hourlyRate: 'hourlyRate',
    timezone: 'timezone',
    availability: 'availability',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    teacherId: 'teacherId',
    scheduledAt: 'scheduledAt',
    duration: 'duration',
    status: 'status',
    meetingUrl: 'meetingUrl',
    notes: 'notes',
    feedback: 'feedback',
    price: 'price',
    paid: 'paid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    stripePaymentIntentId: 'stripePaymentIntentId',
    stripeInvoiceId: 'stripeInvoiceId',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: StringFilter<"User"> | string
    timezone?: StringFilter<"User"> | string
    level?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    refreshToken?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionStatus?: StringFilter<"User"> | string
    subscriptionEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    progress?: UserProgressListRelationFilter
    gamification?: XOR<GamificationNullableRelationFilter, GamificationWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    lessons?: LessonListRelationFilter
    payments?: PaymentListRelationFilter
    speakingSessions?: SpeakingSessionListRelationFilter
    listeningSessions?: ListeningSessionListRelationFilter
    placementTests?: PlacementTestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    country?: SortOrder
    timezone?: SortOrder
    level?: SortOrder
    emailVerified?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrder
    subscriptionEndsAt?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progress?: UserProgressOrderByRelationAggregateInput
    gamification?: GamificationOrderByWithRelationInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    speakingSessions?: SpeakingSessionOrderByRelationAggregateInput
    listeningSessions?: ListeningSessionOrderByRelationAggregateInput
    placementTests?: PlacementTestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    country?: StringFilter<"User"> | string
    timezone?: StringFilter<"User"> | string
    level?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    refreshToken?: StringNullableFilter<"User"> | string | null
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionStatus?: StringFilter<"User"> | string
    subscriptionEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    progress?: UserProgressListRelationFilter
    gamification?: XOR<GamificationNullableRelationFilter, GamificationWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    lessons?: LessonListRelationFilter
    payments?: PaymentListRelationFilter
    speakingSessions?: SpeakingSessionListRelationFilter
    listeningSessions?: ListeningSessionListRelationFilter
    placementTests?: PlacementTestListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    country?: SortOrder
    timezone?: SortOrder
    level?: SortOrder
    emailVerified?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    subscriptionStatus?: SortOrder
    subscriptionEndsAt?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    country?: StringWithAggregatesFilter<"User"> | string
    timezone?: StringWithAggregatesFilter<"User"> | string
    level?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    subscriptionStatus?: StringWithAggregatesFilter<"User"> | string
    subscriptionEndsAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type GamificationWhereInput = {
    AND?: GamificationWhereInput | GamificationWhereInput[]
    OR?: GamificationWhereInput[]
    NOT?: GamificationWhereInput | GamificationWhereInput[]
    id?: StringFilter<"Gamification"> | string
    userId?: StringFilter<"Gamification"> | string
    xp?: IntFilter<"Gamification"> | number
    level?: IntFilter<"Gamification"> | number
    xpToNextLevel?: IntFilter<"Gamification"> | number
    coins?: IntFilter<"Gamification"> | number
    gems?: IntFilter<"Gamification"> | number
    streak?: IntFilter<"Gamification"> | number
    maxStreak?: IntFilter<"Gamification"> | number
    lastActiveDate?: DateTimeFilter<"Gamification"> | Date | string
    rank?: StringFilter<"Gamification"> | string
    createdAt?: DateTimeFilter<"Gamification"> | Date | string
    updatedAt?: DateTimeFilter<"Gamification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type GamificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    xpToNextLevel?: SortOrder
    coins?: SortOrder
    gems?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    lastActiveDate?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GamificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GamificationWhereInput | GamificationWhereInput[]
    OR?: GamificationWhereInput[]
    NOT?: GamificationWhereInput | GamificationWhereInput[]
    xp?: IntFilter<"Gamification"> | number
    level?: IntFilter<"Gamification"> | number
    xpToNextLevel?: IntFilter<"Gamification"> | number
    coins?: IntFilter<"Gamification"> | number
    gems?: IntFilter<"Gamification"> | number
    streak?: IntFilter<"Gamification"> | number
    maxStreak?: IntFilter<"Gamification"> | number
    lastActiveDate?: DateTimeFilter<"Gamification"> | Date | string
    rank?: StringFilter<"Gamification"> | string
    createdAt?: DateTimeFilter<"Gamification"> | Date | string
    updatedAt?: DateTimeFilter<"Gamification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type GamificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    xpToNextLevel?: SortOrder
    coins?: SortOrder
    gems?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    lastActiveDate?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GamificationCountOrderByAggregateInput
    _avg?: GamificationAvgOrderByAggregateInput
    _max?: GamificationMaxOrderByAggregateInput
    _min?: GamificationMinOrderByAggregateInput
    _sum?: GamificationSumOrderByAggregateInput
  }

  export type GamificationScalarWhereWithAggregatesInput = {
    AND?: GamificationScalarWhereWithAggregatesInput | GamificationScalarWhereWithAggregatesInput[]
    OR?: GamificationScalarWhereWithAggregatesInput[]
    NOT?: GamificationScalarWhereWithAggregatesInput | GamificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Gamification"> | string
    userId?: StringWithAggregatesFilter<"Gamification"> | string
    xp?: IntWithAggregatesFilter<"Gamification"> | number
    level?: IntWithAggregatesFilter<"Gamification"> | number
    xpToNextLevel?: IntWithAggregatesFilter<"Gamification"> | number
    coins?: IntWithAggregatesFilter<"Gamification"> | number
    gems?: IntWithAggregatesFilter<"Gamification"> | number
    streak?: IntWithAggregatesFilter<"Gamification"> | number
    maxStreak?: IntWithAggregatesFilter<"Gamification"> | number
    lastActiveDate?: DateTimeWithAggregatesFilter<"Gamification"> | Date | string
    rank?: StringWithAggregatesFilter<"Gamification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Gamification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Gamification"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    category?: StringFilter<"Achievement"> | string
    xpReward?: IntFilter<"Achievement"> | number
    coinsReward?: IntFilter<"Achievement"> | number
    gemsReward?: IntFilter<"Achievement"> | number
    requirement?: IntFilter<"Achievement"> | number
    isSecret?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    xpReward?: SortOrder
    coinsReward?: SortOrder
    gemsReward?: SortOrder
    requirement?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
    userAchievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    category?: StringFilter<"Achievement"> | string
    xpReward?: IntFilter<"Achievement"> | number
    coinsReward?: IntFilter<"Achievement"> | number
    gemsReward?: IntFilter<"Achievement"> | number
    requirement?: IntFilter<"Achievement"> | number
    isSecret?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    xpReward?: SortOrder
    coinsReward?: SortOrder
    gemsReward?: SortOrder
    requirement?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    icon?: StringWithAggregatesFilter<"Achievement"> | string
    category?: StringWithAggregatesFilter<"Achievement"> | string
    xpReward?: IntWithAggregatesFilter<"Achievement"> | number
    coinsReward?: IntWithAggregatesFilter<"Achievement"> | number
    gemsReward?: IntWithAggregatesFilter<"Achievement"> | number
    requirement?: IntWithAggregatesFilter<"Achievement"> | number
    isSecret?: BoolWithAggregatesFilter<"Achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: IntFilter<"UserAchievement"> | number
    unlocked?: BoolFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: IntFilter<"UserAchievement"> | number
    unlocked?: BoolFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlocked?: SortOrder
    unlockedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    progress?: IntWithAggregatesFilter<"UserAchievement"> | number
    unlocked?: BoolWithAggregatesFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableWithAggregatesFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: StringFilter<"Level"> | string
    name?: StringFilter<"Level"> | string
    description?: StringFilter<"Level"> | string
    order?: IntFilter<"Level"> | number
    createdAt?: DateTimeFilter<"Level"> | Date | string
    phrases?: PhraseListRelationFilter
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    phrases?: PhraseOrderByRelationAggregateInput
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    order?: number
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    description?: StringFilter<"Level"> | string
    createdAt?: DateTimeFilter<"Level"> | Date | string
    phrases?: PhraseListRelationFilter
  }, "id" | "name" | "order">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _avg?: LevelAvgOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
    _sum?: LevelSumOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Level"> | string
    name?: StringWithAggregatesFilter<"Level"> | string
    description?: StringWithAggregatesFilter<"Level"> | string
    order?: IntWithAggregatesFilter<"Level"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Level"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    phrases?: PhraseListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    phrases?: PhraseOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    icon?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    createdAt?: DateTimeFilter<"Category"> | Date | string
    phrases?: PhraseListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Category"> | string | null
    order?: IntWithAggregatesFilter<"Category"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type PhraseWhereInput = {
    AND?: PhraseWhereInput | PhraseWhereInput[]
    OR?: PhraseWhereInput[]
    NOT?: PhraseWhereInput | PhraseWhereInput[]
    id?: StringFilter<"Phrase"> | string
    text?: StringFilter<"Phrase"> | string
    translation?: StringFilter<"Phrase"> | string
    audioUrl?: StringNullableFilter<"Phrase"> | string | null
    imageUrl?: StringNullableFilter<"Phrase"> | string | null
    levelId?: StringFilter<"Phrase"> | string
    categoryId?: StringFilter<"Phrase"> | string
    difficulty?: IntFilter<"Phrase"> | number
    tags?: StringNullableListFilter<"Phrase">
    ipaTranscription?: StringNullableFilter<"Phrase"> | string | null
    createdAt?: DateTimeFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeFilter<"Phrase"> | Date | string
    level?: XOR<LevelRelationFilter, LevelWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    progress?: UserProgressListRelationFilter
    speakingAttempts?: SpeakingAttemptListRelationFilter
  }

  export type PhraseOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    translation?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    levelId?: SortOrder
    categoryId?: SortOrder
    difficulty?: SortOrder
    tags?: SortOrder
    ipaTranscription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: LevelOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    progress?: UserProgressOrderByRelationAggregateInput
    speakingAttempts?: SpeakingAttemptOrderByRelationAggregateInput
  }

  export type PhraseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhraseWhereInput | PhraseWhereInput[]
    OR?: PhraseWhereInput[]
    NOT?: PhraseWhereInput | PhraseWhereInput[]
    text?: StringFilter<"Phrase"> | string
    translation?: StringFilter<"Phrase"> | string
    audioUrl?: StringNullableFilter<"Phrase"> | string | null
    imageUrl?: StringNullableFilter<"Phrase"> | string | null
    levelId?: StringFilter<"Phrase"> | string
    categoryId?: StringFilter<"Phrase"> | string
    difficulty?: IntFilter<"Phrase"> | number
    tags?: StringNullableListFilter<"Phrase">
    ipaTranscription?: StringNullableFilter<"Phrase"> | string | null
    createdAt?: DateTimeFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeFilter<"Phrase"> | Date | string
    level?: XOR<LevelRelationFilter, LevelWhereInput>
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    progress?: UserProgressListRelationFilter
    speakingAttempts?: SpeakingAttemptListRelationFilter
  }, "id">

  export type PhraseOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    translation?: SortOrder
    audioUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    levelId?: SortOrder
    categoryId?: SortOrder
    difficulty?: SortOrder
    tags?: SortOrder
    ipaTranscription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PhraseCountOrderByAggregateInput
    _avg?: PhraseAvgOrderByAggregateInput
    _max?: PhraseMaxOrderByAggregateInput
    _min?: PhraseMinOrderByAggregateInput
    _sum?: PhraseSumOrderByAggregateInput
  }

  export type PhraseScalarWhereWithAggregatesInput = {
    AND?: PhraseScalarWhereWithAggregatesInput | PhraseScalarWhereWithAggregatesInput[]
    OR?: PhraseScalarWhereWithAggregatesInput[]
    NOT?: PhraseScalarWhereWithAggregatesInput | PhraseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Phrase"> | string
    text?: StringWithAggregatesFilter<"Phrase"> | string
    translation?: StringWithAggregatesFilter<"Phrase"> | string
    audioUrl?: StringNullableWithAggregatesFilter<"Phrase"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Phrase"> | string | null
    levelId?: StringWithAggregatesFilter<"Phrase"> | string
    categoryId?: StringWithAggregatesFilter<"Phrase"> | string
    difficulty?: IntWithAggregatesFilter<"Phrase"> | number
    tags?: StringNullableListFilter<"Phrase">
    ipaTranscription?: StringNullableWithAggregatesFilter<"Phrase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Phrase"> | Date | string
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    phraseId?: StringFilter<"UserProgress"> | string
    mastery?: IntFilter<"UserProgress"> | number
    attempts?: IntFilter<"UserProgress"> | number
    successes?: IntFilter<"UserProgress"> | number
    lastScore?: IntFilter<"UserProgress"> | number
    bestScore?: IntFilter<"UserProgress"> | number
    easeFactor?: FloatFilter<"UserProgress"> | number
    interval?: IntFilter<"UserProgress"> | number
    nextReview?: DateTimeFilter<"UserProgress"> | Date | string
    lastPracticed?: DateTimeFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    phraseId?: SortOrder
    mastery?: SortOrder
    attempts?: SortOrder
    successes?: SortOrder
    lastScore?: SortOrder
    bestScore?: SortOrder
    easeFactor?: SortOrder
    interval?: SortOrder
    nextReview?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    phrase?: PhraseOrderByWithRelationInput
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_phraseId?: UserProgressUserIdPhraseIdCompoundUniqueInput
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    userId?: StringFilter<"UserProgress"> | string
    phraseId?: StringFilter<"UserProgress"> | string
    mastery?: IntFilter<"UserProgress"> | number
    attempts?: IntFilter<"UserProgress"> | number
    successes?: IntFilter<"UserProgress"> | number
    lastScore?: IntFilter<"UserProgress"> | number
    bestScore?: IntFilter<"UserProgress"> | number
    easeFactor?: FloatFilter<"UserProgress"> | number
    interval?: IntFilter<"UserProgress"> | number
    nextReview?: DateTimeFilter<"UserProgress"> | Date | string
    lastPracticed?: DateTimeFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }, "id" | "userId_phraseId">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    phraseId?: SortOrder
    mastery?: SortOrder
    attempts?: SortOrder
    successes?: SortOrder
    lastScore?: SortOrder
    bestScore?: SortOrder
    easeFactor?: SortOrder
    interval?: SortOrder
    nextReview?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _avg?: UserProgressAvgOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
    _sum?: UserProgressSumOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    phraseId?: StringWithAggregatesFilter<"UserProgress"> | string
    mastery?: IntWithAggregatesFilter<"UserProgress"> | number
    attempts?: IntWithAggregatesFilter<"UserProgress"> | number
    successes?: IntWithAggregatesFilter<"UserProgress"> | number
    lastScore?: IntWithAggregatesFilter<"UserProgress"> | number
    bestScore?: IntWithAggregatesFilter<"UserProgress"> | number
    easeFactor?: FloatWithAggregatesFilter<"UserProgress"> | number
    interval?: IntWithAggregatesFilter<"UserProgress"> | number
    nextReview?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    lastPracticed?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
  }

  export type SpeakingSessionWhereInput = {
    AND?: SpeakingSessionWhereInput | SpeakingSessionWhereInput[]
    OR?: SpeakingSessionWhereInput[]
    NOT?: SpeakingSessionWhereInput | SpeakingSessionWhereInput[]
    id?: StringFilter<"SpeakingSession"> | string
    userId?: StringFilter<"SpeakingSession"> | string
    bestScore?: IntFilter<"SpeakingSession"> | number
    startedAt?: DateTimeFilter<"SpeakingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"SpeakingSession"> | Date | string | null
    totalTime?: IntFilter<"SpeakingSession"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    attempts?: SpeakingAttemptListRelationFilter
  }

  export type SpeakingSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    totalTime?: SortOrder
    user?: UserOrderByWithRelationInput
    attempts?: SpeakingAttemptOrderByRelationAggregateInput
  }

  export type SpeakingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpeakingSessionWhereInput | SpeakingSessionWhereInput[]
    OR?: SpeakingSessionWhereInput[]
    NOT?: SpeakingSessionWhereInput | SpeakingSessionWhereInput[]
    userId?: StringFilter<"SpeakingSession"> | string
    bestScore?: IntFilter<"SpeakingSession"> | number
    startedAt?: DateTimeFilter<"SpeakingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"SpeakingSession"> | Date | string | null
    totalTime?: IntFilter<"SpeakingSession"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    attempts?: SpeakingAttemptListRelationFilter
  }, "id">

  export type SpeakingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    totalTime?: SortOrder
    _count?: SpeakingSessionCountOrderByAggregateInput
    _avg?: SpeakingSessionAvgOrderByAggregateInput
    _max?: SpeakingSessionMaxOrderByAggregateInput
    _min?: SpeakingSessionMinOrderByAggregateInput
    _sum?: SpeakingSessionSumOrderByAggregateInput
  }

  export type SpeakingSessionScalarWhereWithAggregatesInput = {
    AND?: SpeakingSessionScalarWhereWithAggregatesInput | SpeakingSessionScalarWhereWithAggregatesInput[]
    OR?: SpeakingSessionScalarWhereWithAggregatesInput[]
    NOT?: SpeakingSessionScalarWhereWithAggregatesInput | SpeakingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpeakingSession"> | string
    userId?: StringWithAggregatesFilter<"SpeakingSession"> | string
    bestScore?: IntWithAggregatesFilter<"SpeakingSession"> | number
    startedAt?: DateTimeWithAggregatesFilter<"SpeakingSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SpeakingSession"> | Date | string | null
    totalTime?: IntWithAggregatesFilter<"SpeakingSession"> | number
  }

  export type SpeakingAttemptWhereInput = {
    AND?: SpeakingAttemptWhereInput | SpeakingAttemptWhereInput[]
    OR?: SpeakingAttemptWhereInput[]
    NOT?: SpeakingAttemptWhereInput | SpeakingAttemptWhereInput[]
    id?: StringFilter<"SpeakingAttempt"> | string
    sessionId?: StringFilter<"SpeakingAttempt"> | string
    phraseId?: StringFilter<"SpeakingAttempt"> | string
    audioUrl?: StringFilter<"SpeakingAttempt"> | string
    duration?: IntFilter<"SpeakingAttempt"> | number
    transcription?: StringFilter<"SpeakingAttempt"> | string
    overallScore?: IntFilter<"SpeakingAttempt"> | number
    accuracy?: IntFilter<"SpeakingAttempt"> | number
    fluency?: IntFilter<"SpeakingAttempt"> | number
    completeness?: IntFilter<"SpeakingAttempt"> | number
    prosody?: IntFilter<"SpeakingAttempt"> | number
    feedback?: JsonFilter<"SpeakingAttempt">
    mistakes?: JsonFilter<"SpeakingAttempt">
    phonemes?: JsonFilter<"SpeakingAttempt">
    createdAt?: DateTimeFilter<"SpeakingAttempt"> | Date | string
    session?: XOR<SpeakingSessionRelationFilter, SpeakingSessionWhereInput>
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }

  export type SpeakingAttemptOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phraseId?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    transcription?: SortOrder
    overallScore?: SortOrder
    accuracy?: SortOrder
    fluency?: SortOrder
    completeness?: SortOrder
    prosody?: SortOrder
    feedback?: SortOrder
    mistakes?: SortOrder
    phonemes?: SortOrder
    createdAt?: SortOrder
    session?: SpeakingSessionOrderByWithRelationInput
    phrase?: PhraseOrderByWithRelationInput
  }

  export type SpeakingAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpeakingAttemptWhereInput | SpeakingAttemptWhereInput[]
    OR?: SpeakingAttemptWhereInput[]
    NOT?: SpeakingAttemptWhereInput | SpeakingAttemptWhereInput[]
    sessionId?: StringFilter<"SpeakingAttempt"> | string
    phraseId?: StringFilter<"SpeakingAttempt"> | string
    audioUrl?: StringFilter<"SpeakingAttempt"> | string
    duration?: IntFilter<"SpeakingAttempt"> | number
    transcription?: StringFilter<"SpeakingAttempt"> | string
    overallScore?: IntFilter<"SpeakingAttempt"> | number
    accuracy?: IntFilter<"SpeakingAttempt"> | number
    fluency?: IntFilter<"SpeakingAttempt"> | number
    completeness?: IntFilter<"SpeakingAttempt"> | number
    prosody?: IntFilter<"SpeakingAttempt"> | number
    feedback?: JsonFilter<"SpeakingAttempt">
    mistakes?: JsonFilter<"SpeakingAttempt">
    phonemes?: JsonFilter<"SpeakingAttempt">
    createdAt?: DateTimeFilter<"SpeakingAttempt"> | Date | string
    session?: XOR<SpeakingSessionRelationFilter, SpeakingSessionWhereInput>
    phrase?: XOR<PhraseRelationFilter, PhraseWhereInput>
  }, "id">

  export type SpeakingAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phraseId?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    transcription?: SortOrder
    overallScore?: SortOrder
    accuracy?: SortOrder
    fluency?: SortOrder
    completeness?: SortOrder
    prosody?: SortOrder
    feedback?: SortOrder
    mistakes?: SortOrder
    phonemes?: SortOrder
    createdAt?: SortOrder
    _count?: SpeakingAttemptCountOrderByAggregateInput
    _avg?: SpeakingAttemptAvgOrderByAggregateInput
    _max?: SpeakingAttemptMaxOrderByAggregateInput
    _min?: SpeakingAttemptMinOrderByAggregateInput
    _sum?: SpeakingAttemptSumOrderByAggregateInput
  }

  export type SpeakingAttemptScalarWhereWithAggregatesInput = {
    AND?: SpeakingAttemptScalarWhereWithAggregatesInput | SpeakingAttemptScalarWhereWithAggregatesInput[]
    OR?: SpeakingAttemptScalarWhereWithAggregatesInput[]
    NOT?: SpeakingAttemptScalarWhereWithAggregatesInput | SpeakingAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpeakingAttempt"> | string
    sessionId?: StringWithAggregatesFilter<"SpeakingAttempt"> | string
    phraseId?: StringWithAggregatesFilter<"SpeakingAttempt"> | string
    audioUrl?: StringWithAggregatesFilter<"SpeakingAttempt"> | string
    duration?: IntWithAggregatesFilter<"SpeakingAttempt"> | number
    transcription?: StringWithAggregatesFilter<"SpeakingAttempt"> | string
    overallScore?: IntWithAggregatesFilter<"SpeakingAttempt"> | number
    accuracy?: IntWithAggregatesFilter<"SpeakingAttempt"> | number
    fluency?: IntWithAggregatesFilter<"SpeakingAttempt"> | number
    completeness?: IntWithAggregatesFilter<"SpeakingAttempt"> | number
    prosody?: IntWithAggregatesFilter<"SpeakingAttempt"> | number
    feedback?: JsonWithAggregatesFilter<"SpeakingAttempt">
    mistakes?: JsonWithAggregatesFilter<"SpeakingAttempt">
    phonemes?: JsonWithAggregatesFilter<"SpeakingAttempt">
    createdAt?: DateTimeWithAggregatesFilter<"SpeakingAttempt"> | Date | string
  }

  export type ListeningSessionWhereInput = {
    AND?: ListeningSessionWhereInput | ListeningSessionWhereInput[]
    OR?: ListeningSessionWhereInput[]
    NOT?: ListeningSessionWhereInput | ListeningSessionWhereInput[]
    id?: StringFilter<"ListeningSession"> | string
    userId?: StringFilter<"ListeningSession"> | string
    exerciseType?: StringFilter<"ListeningSession"> | string
    accent?: StringFilter<"ListeningSession"> | string
    speed?: FloatFilter<"ListeningSession"> | number
    exercises?: JsonFilter<"ListeningSession">
    answers?: JsonFilter<"ListeningSession">
    score?: IntFilter<"ListeningSession"> | number
    timeSpent?: IntFilter<"ListeningSession"> | number
    completedAt?: DateTimeNullableFilter<"ListeningSession"> | Date | string | null
    createdAt?: DateTimeFilter<"ListeningSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ListeningSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    accent?: SortOrder
    speed?: SortOrder
    exercises?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ListeningSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ListeningSessionWhereInput | ListeningSessionWhereInput[]
    OR?: ListeningSessionWhereInput[]
    NOT?: ListeningSessionWhereInput | ListeningSessionWhereInput[]
    userId?: StringFilter<"ListeningSession"> | string
    exerciseType?: StringFilter<"ListeningSession"> | string
    accent?: StringFilter<"ListeningSession"> | string
    speed?: FloatFilter<"ListeningSession"> | number
    exercises?: JsonFilter<"ListeningSession">
    answers?: JsonFilter<"ListeningSession">
    score?: IntFilter<"ListeningSession"> | number
    timeSpent?: IntFilter<"ListeningSession"> | number
    completedAt?: DateTimeNullableFilter<"ListeningSession"> | Date | string | null
    createdAt?: DateTimeFilter<"ListeningSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ListeningSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    accent?: SortOrder
    speed?: SortOrder
    exercises?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ListeningSessionCountOrderByAggregateInput
    _avg?: ListeningSessionAvgOrderByAggregateInput
    _max?: ListeningSessionMaxOrderByAggregateInput
    _min?: ListeningSessionMinOrderByAggregateInput
    _sum?: ListeningSessionSumOrderByAggregateInput
  }

  export type ListeningSessionScalarWhereWithAggregatesInput = {
    AND?: ListeningSessionScalarWhereWithAggregatesInput | ListeningSessionScalarWhereWithAggregatesInput[]
    OR?: ListeningSessionScalarWhereWithAggregatesInput[]
    NOT?: ListeningSessionScalarWhereWithAggregatesInput | ListeningSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ListeningSession"> | string
    userId?: StringWithAggregatesFilter<"ListeningSession"> | string
    exerciseType?: StringWithAggregatesFilter<"ListeningSession"> | string
    accent?: StringWithAggregatesFilter<"ListeningSession"> | string
    speed?: FloatWithAggregatesFilter<"ListeningSession"> | number
    exercises?: JsonWithAggregatesFilter<"ListeningSession">
    answers?: JsonWithAggregatesFilter<"ListeningSession">
    score?: IntWithAggregatesFilter<"ListeningSession"> | number
    timeSpent?: IntWithAggregatesFilter<"ListeningSession"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"ListeningSession"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ListeningSession"> | Date | string
  }

  export type PlacementTestWhereInput = {
    AND?: PlacementTestWhereInput | PlacementTestWhereInput[]
    OR?: PlacementTestWhereInput[]
    NOT?: PlacementTestWhereInput | PlacementTestWhereInput[]
    id?: StringFilter<"PlacementTest"> | string
    userId?: StringFilter<"PlacementTest"> | string
    questions?: JsonFilter<"PlacementTest">
    answers?: JsonFilter<"PlacementTest">
    theta?: FloatFilter<"PlacementTest"> | number
    standardError?: FloatFilter<"PlacementTest"> | number
    level?: StringFilter<"PlacementTest"> | string
    score?: IntFilter<"PlacementTest"> | number
    completedAt?: DateTimeNullableFilter<"PlacementTest"> | Date | string | null
    createdAt?: DateTimeFilter<"PlacementTest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PlacementTestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    theta?: SortOrder
    standardError?: SortOrder
    level?: SortOrder
    score?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PlacementTestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlacementTestWhereInput | PlacementTestWhereInput[]
    OR?: PlacementTestWhereInput[]
    NOT?: PlacementTestWhereInput | PlacementTestWhereInput[]
    userId?: StringFilter<"PlacementTest"> | string
    questions?: JsonFilter<"PlacementTest">
    answers?: JsonFilter<"PlacementTest">
    theta?: FloatFilter<"PlacementTest"> | number
    standardError?: FloatFilter<"PlacementTest"> | number
    level?: StringFilter<"PlacementTest"> | string
    score?: IntFilter<"PlacementTest"> | number
    completedAt?: DateTimeNullableFilter<"PlacementTest"> | Date | string | null
    createdAt?: DateTimeFilter<"PlacementTest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PlacementTestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    theta?: SortOrder
    standardError?: SortOrder
    level?: SortOrder
    score?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PlacementTestCountOrderByAggregateInput
    _avg?: PlacementTestAvgOrderByAggregateInput
    _max?: PlacementTestMaxOrderByAggregateInput
    _min?: PlacementTestMinOrderByAggregateInput
    _sum?: PlacementTestSumOrderByAggregateInput
  }

  export type PlacementTestScalarWhereWithAggregatesInput = {
    AND?: PlacementTestScalarWhereWithAggregatesInput | PlacementTestScalarWhereWithAggregatesInput[]
    OR?: PlacementTestScalarWhereWithAggregatesInput[]
    NOT?: PlacementTestScalarWhereWithAggregatesInput | PlacementTestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlacementTest"> | string
    userId?: StringWithAggregatesFilter<"PlacementTest"> | string
    questions?: JsonWithAggregatesFilter<"PlacementTest">
    answers?: JsonWithAggregatesFilter<"PlacementTest">
    theta?: FloatWithAggregatesFilter<"PlacementTest"> | number
    standardError?: FloatWithAggregatesFilter<"PlacementTest"> | number
    level?: StringWithAggregatesFilter<"PlacementTest"> | string
    score?: IntWithAggregatesFilter<"PlacementTest"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"PlacementTest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlacementTest"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    name?: StringFilter<"Teacher"> | string
    email?: StringFilter<"Teacher"> | string
    avatar?: StringNullableFilter<"Teacher"> | string | null
    bio?: StringNullableFilter<"Teacher"> | string | null
    certifications?: StringNullableListFilter<"Teacher">
    specializations?: StringNullableListFilter<"Teacher">
    languages?: StringNullableListFilter<"Teacher">
    rating?: FloatFilter<"Teacher"> | number
    totalLessons?: IntFilter<"Teacher"> | number
    experience?: IntFilter<"Teacher"> | number
    hourlyRate?: IntFilter<"Teacher"> | number
    timezone?: StringFilter<"Teacher"> | string
    availability?: JsonFilter<"Teacher">
    isActive?: BoolFilter<"Teacher"> | boolean
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    lessons?: LessonListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    certifications?: SortOrder
    specializations?: SortOrder
    languages?: SortOrder
    rating?: SortOrder
    totalLessons?: SortOrder
    experience?: SortOrder
    hourlyRate?: SortOrder
    timezone?: SortOrder
    availability?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    name?: StringFilter<"Teacher"> | string
    avatar?: StringNullableFilter<"Teacher"> | string | null
    bio?: StringNullableFilter<"Teacher"> | string | null
    certifications?: StringNullableListFilter<"Teacher">
    specializations?: StringNullableListFilter<"Teacher">
    languages?: StringNullableListFilter<"Teacher">
    rating?: FloatFilter<"Teacher"> | number
    totalLessons?: IntFilter<"Teacher"> | number
    experience?: IntFilter<"Teacher"> | number
    hourlyRate?: IntFilter<"Teacher"> | number
    timezone?: StringFilter<"Teacher"> | string
    availability?: JsonFilter<"Teacher">
    isActive?: BoolFilter<"Teacher"> | boolean
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    lessons?: LessonListRelationFilter
  }, "id" | "email">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    avatar?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    certifications?: SortOrder
    specializations?: SortOrder
    languages?: SortOrder
    rating?: SortOrder
    totalLessons?: SortOrder
    experience?: SortOrder
    hourlyRate?: SortOrder
    timezone?: SortOrder
    availability?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _avg?: TeacherAvgOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
    _sum?: TeacherSumOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    name?: StringWithAggregatesFilter<"Teacher"> | string
    email?: StringWithAggregatesFilter<"Teacher"> | string
    avatar?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    bio?: StringNullableWithAggregatesFilter<"Teacher"> | string | null
    certifications?: StringNullableListFilter<"Teacher">
    specializations?: StringNullableListFilter<"Teacher">
    languages?: StringNullableListFilter<"Teacher">
    rating?: FloatWithAggregatesFilter<"Teacher"> | number
    totalLessons?: IntWithAggregatesFilter<"Teacher"> | number
    experience?: IntWithAggregatesFilter<"Teacher"> | number
    hourlyRate?: IntWithAggregatesFilter<"Teacher"> | number
    timezone?: StringWithAggregatesFilter<"Teacher"> | string
    availability?: JsonWithAggregatesFilter<"Teacher">
    isActive?: BoolWithAggregatesFilter<"Teacher"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    studentId?: StringFilter<"Lesson"> | string
    teacherId?: StringFilter<"Lesson"> | string
    scheduledAt?: DateTimeFilter<"Lesson"> | Date | string
    duration?: IntFilter<"Lesson"> | number
    status?: StringFilter<"Lesson"> | string
    meetingUrl?: StringNullableFilter<"Lesson"> | string | null
    notes?: StringNullableFilter<"Lesson"> | string | null
    feedback?: StringNullableFilter<"Lesson"> | string | null
    price?: IntFilter<"Lesson"> | number
    paid?: BoolFilter<"Lesson"> | boolean
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    student?: XOR<UserRelationFilter, UserWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: UserOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    studentId?: StringFilter<"Lesson"> | string
    teacherId?: StringFilter<"Lesson"> | string
    scheduledAt?: DateTimeFilter<"Lesson"> | Date | string
    duration?: IntFilter<"Lesson"> | number
    status?: StringFilter<"Lesson"> | string
    meetingUrl?: StringNullableFilter<"Lesson"> | string | null
    notes?: StringNullableFilter<"Lesson"> | string | null
    feedback?: StringNullableFilter<"Lesson"> | string | null
    price?: IntFilter<"Lesson"> | number
    paid?: BoolFilter<"Lesson"> | boolean
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    student?: XOR<UserRelationFilter, UserWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    studentId?: StringWithAggregatesFilter<"Lesson"> | string
    teacherId?: StringWithAggregatesFilter<"Lesson"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    duration?: IntWithAggregatesFilter<"Lesson"> | number
    status?: StringWithAggregatesFilter<"Lesson"> | string
    meetingUrl?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    feedback?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    price?: IntWithAggregatesFilter<"Lesson"> | number
    paid?: BoolWithAggregatesFilter<"Lesson"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    description?: StringFilter<"Payment"> | string
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentIntentId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    description?: StringFilter<"Payment"> | string
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "stripePaymentIntentId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    description?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: IntWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    description?: StringWithAggregatesFilter<"Payment"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    gamification?: GamificationCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamificationCreateInput = {
    id?: string
    xp?: number
    level?: number
    xpToNextLevel?: number
    coins?: number
    gems?: number
    streak?: number
    maxStreak?: number
    lastActiveDate?: Date | string
    rank?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGamificationInput
  }

  export type GamificationUncheckedCreateInput = {
    id?: string
    userId: string
    xp?: number
    level?: number
    xpToNextLevel?: number
    coins?: number
    gems?: number
    streak?: number
    maxStreak?: number
    lastActiveDate?: Date | string
    rank?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rank?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGamificationNestedInput
  }

  export type GamificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rank?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamificationCreateManyInput = {
    id?: string
    userId: string
    xp?: number
    level?: number
    xpToNextLevel?: number
    coins?: number
    gems?: number
    streak?: number
    maxStreak?: number
    lastActiveDate?: Date | string
    rank?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rank?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rank?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: string
    xpReward?: number
    coinsReward?: number
    gemsReward?: number
    requirement: number
    isSecret?: boolean
    createdAt?: Date | string
    userAchievements?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: string
    xpReward?: number
    coinsReward?: number
    gemsReward?: number
    requirement: number
    isSecret?: boolean
    createdAt?: Date | string
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    coinsReward?: IntFieldUpdateOperationsInput | number
    gemsReward?: IntFieldUpdateOperationsInput | number
    requirement?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    coinsReward?: IntFieldUpdateOperationsInput | number
    gemsReward?: IntFieldUpdateOperationsInput | number
    requirement?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: string
    xpReward?: number
    coinsReward?: number
    gemsReward?: number
    requirement: number
    isSecret?: boolean
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    coinsReward?: IntFieldUpdateOperationsInput | number
    gemsReward?: IntFieldUpdateOperationsInput | number
    requirement?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    coinsReward?: IntFieldUpdateOperationsInput | number
    gemsReward?: IntFieldUpdateOperationsInput | number
    requirement?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelCreateInput = {
    id?: string
    name: string
    description: string
    order: number
    createdAt?: Date | string
    phrases?: PhraseCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    order: number
    createdAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelCreateManyInput = {
    id?: string
    name: string
    description: string
    order: number
    createdAt?: Date | string
  }

  export type LevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    phrases?: PhraseCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
    phrases?: PhraseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrases?: PhraseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseCreateInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level: LevelCreateNestedOneWithoutPhrasesInput
    category: CategoryCreateNestedOneWithoutPhrasesInput
    progress?: UserProgressCreateNestedManyWithoutPhraseInput
    speakingAttempts?: SpeakingAttemptCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    levelId: string
    categoryId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutPhraseInput
    speakingAttempts?: SpeakingAttemptUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: LevelUpdateOneRequiredWithoutPhrasesNestedInput
    category?: CategoryUpdateOneRequiredWithoutPhrasesNestedInput
    progress?: UserProgressUpdateManyWithoutPhraseNestedInput
    speakingAttempts?: SpeakingAttemptUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutPhraseNestedInput
    speakingAttempts?: SpeakingAttemptUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseCreateManyInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    levelId: string
    categoryId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhraseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateInput = {
    id?: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProgressInput
    phrase: PhraseCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    phraseId: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
    phrase?: PhraseUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    phraseId: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingSessionCreateInput = {
    id?: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
    user: UserCreateNestedOneWithoutSpeakingSessionsInput
    attempts?: SpeakingAttemptCreateNestedManyWithoutSessionInput
  }

  export type SpeakingSessionUncheckedCreateInput = {
    id?: string
    userId: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
    attempts?: SpeakingAttemptUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SpeakingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutSpeakingSessionsNestedInput
    attempts?: SpeakingAttemptUpdateManyWithoutSessionNestedInput
  }

  export type SpeakingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
    attempts?: SpeakingAttemptUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SpeakingSessionCreateManyInput = {
    id?: string
    userId: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
  }

  export type SpeakingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakingAttemptCreateInput = {
    id?: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    session: SpeakingSessionCreateNestedOneWithoutAttemptsInput
    phrase: PhraseCreateNestedOneWithoutSpeakingAttemptsInput
  }

  export type SpeakingAttemptUncheckedCreateInput = {
    id?: string
    sessionId: string
    phraseId: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SpeakingAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SpeakingSessionUpdateOneRequiredWithoutAttemptsNestedInput
    phrase?: PhraseUpdateOneRequiredWithoutSpeakingAttemptsNestedInput
  }

  export type SpeakingAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingAttemptCreateManyInput = {
    id?: string
    sessionId: string
    phraseId: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SpeakingAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningSessionCreateInput = {
    id?: string
    exerciseType: string
    accent: string
    speed: number
    exercises: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    score?: number
    timeSpent?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutListeningSessionsInput
  }

  export type ListeningSessionUncheckedCreateInput = {
    id?: string
    userId: string
    exerciseType: string
    accent: string
    speed: number
    exercises: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    score?: number
    timeSpent?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ListeningSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseType?: StringFieldUpdateOperationsInput | string
    accent?: StringFieldUpdateOperationsInput | string
    speed?: FloatFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutListeningSessionsNestedInput
  }

  export type ListeningSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: StringFieldUpdateOperationsInput | string
    accent?: StringFieldUpdateOperationsInput | string
    speed?: FloatFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningSessionCreateManyInput = {
    id?: string
    userId: string
    exerciseType: string
    accent: string
    speed: number
    exercises: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    score?: number
    timeSpent?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ListeningSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseType?: StringFieldUpdateOperationsInput | string
    accent?: StringFieldUpdateOperationsInput | string
    speed?: FloatFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    exerciseType?: StringFieldUpdateOperationsInput | string
    accent?: StringFieldUpdateOperationsInput | string
    speed?: FloatFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementTestCreateInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    theta: number
    standardError: number
    level: string
    score: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPlacementTestsInput
  }

  export type PlacementTestUncheckedCreateInput = {
    id?: string
    userId: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    theta: number
    standardError: number
    level: string
    score: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PlacementTestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    theta?: FloatFieldUpdateOperationsInput | number
    standardError?: FloatFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPlacementTestsNestedInput
  }

  export type PlacementTestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    theta?: FloatFieldUpdateOperationsInput | number
    standardError?: FloatFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementTestCreateManyInput = {
    id?: string
    userId: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    theta: number
    standardError: number
    level: string
    score: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PlacementTestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    theta?: FloatFieldUpdateOperationsInput | number
    standardError?: FloatFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementTestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    theta?: FloatFieldUpdateOperationsInput | number
    standardError?: FloatFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    name: string
    email: string
    avatar?: string | null
    bio?: string | null
    certifications?: TeacherCreatecertificationsInput | string[]
    specializations?: TeacherCreatespecializationsInput | string[]
    languages?: TeacherCreatelanguagesInput | string[]
    rating?: number
    totalLessons?: number
    experience?: number
    hourlyRate: number
    timezone?: string
    availability: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    avatar?: string | null
    bio?: string | null
    certifications?: TeacherCreatecertificationsInput | string[]
    specializations?: TeacherCreatespecializationsInput | string[]
    languages?: TeacherCreatelanguagesInput | string[]
    rating?: number
    totalLessons?: number
    experience?: number
    hourlyRate: number
    timezone?: string
    availability: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: TeacherUpdatecertificationsInput | string[]
    specializations?: TeacherUpdatespecializationsInput | string[]
    languages?: TeacherUpdatelanguagesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    hourlyRate?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    availability?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: TeacherUpdatecertificationsInput | string[]
    specializations?: TeacherUpdatespecializationsInput | string[]
    languages?: TeacherUpdatelanguagesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    hourlyRate?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    availability?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    name: string
    email: string
    avatar?: string | null
    bio?: string | null
    certifications?: TeacherCreatecertificationsInput | string[]
    specializations?: TeacherCreatespecializationsInput | string[]
    languages?: TeacherCreatelanguagesInput | string[]
    rating?: number
    totalLessons?: number
    experience?: number
    hourlyRate: number
    timezone?: string
    availability: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: TeacherUpdatecertificationsInput | string[]
    specializations?: TeacherUpdatespecializationsInput | string[]
    languages?: TeacherUpdatelanguagesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    hourlyRate?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    availability?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: TeacherUpdatecertificationsInput | string[]
    specializations?: TeacherUpdatespecializationsInput | string[]
    languages?: TeacherUpdatelanguagesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    hourlyRate?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    availability?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: UserCreateNestedOneWithoutLessonsInput
    teacher: TeacherCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    studentId: string
    teacherId: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutLessonsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateManyInput = {
    id?: string
    studentId: string
    teacherId: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserProgressListRelationFilter = {
    every?: UserProgressWhereInput
    some?: UserProgressWhereInput
    none?: UserProgressWhereInput
  }

  export type GamificationNullableRelationFilter = {
    is?: GamificationWhereInput | null
    isNot?: GamificationWhereInput | null
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SpeakingSessionListRelationFilter = {
    every?: SpeakingSessionWhereInput
    some?: SpeakingSessionWhereInput
    none?: SpeakingSessionWhereInput
  }

  export type ListeningSessionListRelationFilter = {
    every?: ListeningSessionWhereInput
    some?: ListeningSessionWhereInput
    none?: ListeningSessionWhereInput
  }

  export type PlacementTestListRelationFilter = {
    every?: PlacementTestWhereInput
    some?: PlacementTestWhereInput
    none?: PlacementTestWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeakingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListeningSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlacementTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    level?: SortOrder
    emailVerified?: SortOrder
    refreshToken?: SortOrder
    lastLogin?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionEndsAt?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    level?: SortOrder
    emailVerified?: SortOrder
    refreshToken?: SortOrder
    lastLogin?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionEndsAt?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    country?: SortOrder
    timezone?: SortOrder
    level?: SortOrder
    emailVerified?: SortOrder
    refreshToken?: SortOrder
    lastLogin?: SortOrder
    subscriptionStatus?: SortOrder
    subscriptionEndsAt?: SortOrder
    stripeCustomerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type GamificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    xpToNextLevel?: SortOrder
    coins?: SortOrder
    gems?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    lastActiveDate?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GamificationAvgOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
    xpToNextLevel?: SortOrder
    coins?: SortOrder
    gems?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
  }

  export type GamificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    xpToNextLevel?: SortOrder
    coins?: SortOrder
    gems?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    lastActiveDate?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GamificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    xp?: SortOrder
    level?: SortOrder
    xpToNextLevel?: SortOrder
    coins?: SortOrder
    gems?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    lastActiveDate?: SortOrder
    rank?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GamificationSumOrderByAggregateInput = {
    xp?: SortOrder
    level?: SortOrder
    xpToNextLevel?: SortOrder
    coins?: SortOrder
    gems?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    xpReward?: SortOrder
    coinsReward?: SortOrder
    gemsReward?: SortOrder
    requirement?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    xpReward?: SortOrder
    coinsReward?: SortOrder
    gemsReward?: SortOrder
    requirement?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    xpReward?: SortOrder
    coinsReward?: SortOrder
    gemsReward?: SortOrder
    requirement?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    xpReward?: SortOrder
    coinsReward?: SortOrder
    gemsReward?: SortOrder
    requirement?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    xpReward?: SortOrder
    coinsReward?: SortOrder
    gemsReward?: SortOrder
    requirement?: SortOrder
  }

  export type AchievementRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    progress?: SortOrder
    unlocked?: SortOrder
    unlockedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type PhraseListRelationFilter = {
    every?: PhraseWhereInput
    some?: PhraseWhereInput
    none?: PhraseWhereInput
  }

  export type PhraseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type LevelAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type LevelSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LevelRelationFilter = {
    is?: LevelWhereInput
    isNot?: LevelWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type SpeakingAttemptListRelationFilter = {
    every?: SpeakingAttemptWhereInput
    some?: SpeakingAttemptWhereInput
    none?: SpeakingAttemptWhereInput
  }

  export type SpeakingAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhraseCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    translation?: SortOrder
    audioUrl?: SortOrder
    imageUrl?: SortOrder
    levelId?: SortOrder
    categoryId?: SortOrder
    difficulty?: SortOrder
    tags?: SortOrder
    ipaTranscription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhraseAvgOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type PhraseMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    translation?: SortOrder
    audioUrl?: SortOrder
    imageUrl?: SortOrder
    levelId?: SortOrder
    categoryId?: SortOrder
    difficulty?: SortOrder
    ipaTranscription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhraseMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    translation?: SortOrder
    audioUrl?: SortOrder
    imageUrl?: SortOrder
    levelId?: SortOrder
    categoryId?: SortOrder
    difficulty?: SortOrder
    ipaTranscription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PhraseSumOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PhraseRelationFilter = {
    is?: PhraseWhereInput
    isNot?: PhraseWhereInput
  }

  export type UserProgressUserIdPhraseIdCompoundUniqueInput = {
    userId: string
    phraseId: string
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phraseId?: SortOrder
    mastery?: SortOrder
    attempts?: SortOrder
    successes?: SortOrder
    lastScore?: SortOrder
    bestScore?: SortOrder
    easeFactor?: SortOrder
    interval?: SortOrder
    nextReview?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressAvgOrderByAggregateInput = {
    mastery?: SortOrder
    attempts?: SortOrder
    successes?: SortOrder
    lastScore?: SortOrder
    bestScore?: SortOrder
    easeFactor?: SortOrder
    interval?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phraseId?: SortOrder
    mastery?: SortOrder
    attempts?: SortOrder
    successes?: SortOrder
    lastScore?: SortOrder
    bestScore?: SortOrder
    easeFactor?: SortOrder
    interval?: SortOrder
    nextReview?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phraseId?: SortOrder
    mastery?: SortOrder
    attempts?: SortOrder
    successes?: SortOrder
    lastScore?: SortOrder
    bestScore?: SortOrder
    easeFactor?: SortOrder
    interval?: SortOrder
    nextReview?: SortOrder
    lastPracticed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressSumOrderByAggregateInput = {
    mastery?: SortOrder
    attempts?: SortOrder
    successes?: SortOrder
    lastScore?: SortOrder
    bestScore?: SortOrder
    easeFactor?: SortOrder
    interval?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type SpeakingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    totalTime?: SortOrder
  }

  export type SpeakingSessionAvgOrderByAggregateInput = {
    bestScore?: SortOrder
    totalTime?: SortOrder
  }

  export type SpeakingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    totalTime?: SortOrder
  }

  export type SpeakingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bestScore?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    totalTime?: SortOrder
  }

  export type SpeakingSessionSumOrderByAggregateInput = {
    bestScore?: SortOrder
    totalTime?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SpeakingSessionRelationFilter = {
    is?: SpeakingSessionWhereInput
    isNot?: SpeakingSessionWhereInput
  }

  export type SpeakingAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phraseId?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    transcription?: SortOrder
    overallScore?: SortOrder
    accuracy?: SortOrder
    fluency?: SortOrder
    completeness?: SortOrder
    prosody?: SortOrder
    feedback?: SortOrder
    mistakes?: SortOrder
    phonemes?: SortOrder
    createdAt?: SortOrder
  }

  export type SpeakingAttemptAvgOrderByAggregateInput = {
    duration?: SortOrder
    overallScore?: SortOrder
    accuracy?: SortOrder
    fluency?: SortOrder
    completeness?: SortOrder
    prosody?: SortOrder
  }

  export type SpeakingAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phraseId?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    transcription?: SortOrder
    overallScore?: SortOrder
    accuracy?: SortOrder
    fluency?: SortOrder
    completeness?: SortOrder
    prosody?: SortOrder
    createdAt?: SortOrder
  }

  export type SpeakingAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    phraseId?: SortOrder
    audioUrl?: SortOrder
    duration?: SortOrder
    transcription?: SortOrder
    overallScore?: SortOrder
    accuracy?: SortOrder
    fluency?: SortOrder
    completeness?: SortOrder
    prosody?: SortOrder
    createdAt?: SortOrder
  }

  export type SpeakingAttemptSumOrderByAggregateInput = {
    duration?: SortOrder
    overallScore?: SortOrder
    accuracy?: SortOrder
    fluency?: SortOrder
    completeness?: SortOrder
    prosody?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ListeningSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    accent?: SortOrder
    speed?: SortOrder
    exercises?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ListeningSessionAvgOrderByAggregateInput = {
    speed?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
  }

  export type ListeningSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    accent?: SortOrder
    speed?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ListeningSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    exerciseType?: SortOrder
    accent?: SortOrder
    speed?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ListeningSessionSumOrderByAggregateInput = {
    speed?: SortOrder
    score?: SortOrder
    timeSpent?: SortOrder
  }

  export type PlacementTestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    questions?: SortOrder
    answers?: SortOrder
    theta?: SortOrder
    standardError?: SortOrder
    level?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PlacementTestAvgOrderByAggregateInput = {
    theta?: SortOrder
    standardError?: SortOrder
    score?: SortOrder
  }

  export type PlacementTestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theta?: SortOrder
    standardError?: SortOrder
    level?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PlacementTestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    theta?: SortOrder
    standardError?: SortOrder
    level?: SortOrder
    score?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PlacementTestSumOrderByAggregateInput = {
    theta?: SortOrder
    standardError?: SortOrder
    score?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    certifications?: SortOrder
    specializations?: SortOrder
    languages?: SortOrder
    rating?: SortOrder
    totalLessons?: SortOrder
    experience?: SortOrder
    hourlyRate?: SortOrder
    timezone?: SortOrder
    availability?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherAvgOrderByAggregateInput = {
    rating?: SortOrder
    totalLessons?: SortOrder
    experience?: SortOrder
    hourlyRate?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    rating?: SortOrder
    totalLessons?: SortOrder
    experience?: SortOrder
    hourlyRate?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    avatar?: SortOrder
    bio?: SortOrder
    rating?: SortOrder
    totalLessons?: SortOrder
    experience?: SortOrder
    hourlyRate?: SortOrder
    timezone?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherSumOrderByAggregateInput = {
    rating?: SortOrder
    totalLessons?: SortOrder
    experience?: SortOrder
    hourlyRate?: SortOrder
  }

  export type TeacherRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingUrl?: SortOrder
    notes?: SortOrder
    feedback?: SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingUrl?: SortOrder
    notes?: SortOrder
    feedback?: SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    scheduledAt?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    meetingUrl?: SortOrder
    notes?: SortOrder
    feedback?: SortOrder
    price?: SortOrder
    paid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    duration?: SortOrder
    price?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeInvoiceId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeInvoiceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeInvoiceId?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UserProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type GamificationCreateNestedOneWithoutUserInput = {
    create?: XOR<GamificationCreateWithoutUserInput, GamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: GamificationCreateOrConnectWithoutUserInput
    connect?: GamificationWhereUniqueInput
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutStudentInput = {
    create?: XOR<LessonCreateWithoutStudentInput, LessonUncheckedCreateWithoutStudentInput> | LessonCreateWithoutStudentInput[] | LessonUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentInput | LessonCreateOrConnectWithoutStudentInput[]
    createMany?: LessonCreateManyStudentInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SpeakingSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SpeakingSessionCreateWithoutUserInput, SpeakingSessionUncheckedCreateWithoutUserInput> | SpeakingSessionCreateWithoutUserInput[] | SpeakingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpeakingSessionCreateOrConnectWithoutUserInput | SpeakingSessionCreateOrConnectWithoutUserInput[]
    createMany?: SpeakingSessionCreateManyUserInputEnvelope
    connect?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
  }

  export type ListeningSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ListeningSessionCreateWithoutUserInput, ListeningSessionUncheckedCreateWithoutUserInput> | ListeningSessionCreateWithoutUserInput[] | ListeningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningSessionCreateOrConnectWithoutUserInput | ListeningSessionCreateOrConnectWithoutUserInput[]
    createMany?: ListeningSessionCreateManyUserInputEnvelope
    connect?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
  }

  export type PlacementTestCreateNestedManyWithoutUserInput = {
    create?: XOR<PlacementTestCreateWithoutUserInput, PlacementTestUncheckedCreateWithoutUserInput> | PlacementTestCreateWithoutUserInput[] | PlacementTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlacementTestCreateOrConnectWithoutUserInput | PlacementTestCreateOrConnectWithoutUserInput[]
    createMany?: PlacementTestCreateManyUserInputEnvelope
    connect?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type GamificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GamificationCreateWithoutUserInput, GamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: GamificationCreateOrConnectWithoutUserInput
    connect?: GamificationWhereUniqueInput
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<LessonCreateWithoutStudentInput, LessonUncheckedCreateWithoutStudentInput> | LessonCreateWithoutStudentInput[] | LessonUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentInput | LessonCreateOrConnectWithoutStudentInput[]
    createMany?: LessonCreateManyStudentInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SpeakingSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SpeakingSessionCreateWithoutUserInput, SpeakingSessionUncheckedCreateWithoutUserInput> | SpeakingSessionCreateWithoutUserInput[] | SpeakingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpeakingSessionCreateOrConnectWithoutUserInput | SpeakingSessionCreateOrConnectWithoutUserInput[]
    createMany?: SpeakingSessionCreateManyUserInputEnvelope
    connect?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
  }

  export type ListeningSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ListeningSessionCreateWithoutUserInput, ListeningSessionUncheckedCreateWithoutUserInput> | ListeningSessionCreateWithoutUserInput[] | ListeningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningSessionCreateOrConnectWithoutUserInput | ListeningSessionCreateOrConnectWithoutUserInput[]
    createMany?: ListeningSessionCreateManyUserInputEnvelope
    connect?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
  }

  export type PlacementTestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlacementTestCreateWithoutUserInput, PlacementTestUncheckedCreateWithoutUserInput> | PlacementTestCreateWithoutUserInput[] | PlacementTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlacementTestCreateOrConnectWithoutUserInput | PlacementTestCreateOrConnectWithoutUserInput[]
    createMany?: PlacementTestCreateManyUserInputEnvelope
    connect?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type GamificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<GamificationCreateWithoutUserInput, GamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: GamificationCreateOrConnectWithoutUserInput
    upsert?: GamificationUpsertWithoutUserInput
    disconnect?: GamificationWhereInput | boolean
    delete?: GamificationWhereInput | boolean
    connect?: GamificationWhereUniqueInput
    update?: XOR<XOR<GamificationUpdateToOneWithWhereWithoutUserInput, GamificationUpdateWithoutUserInput>, GamificationUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LessonCreateWithoutStudentInput, LessonUncheckedCreateWithoutStudentInput> | LessonCreateWithoutStudentInput[] | LessonUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentInput | LessonCreateOrConnectWithoutStudentInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutStudentInput | LessonUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LessonCreateManyStudentInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutStudentInput | LessonUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutStudentInput | LessonUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SpeakingSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SpeakingSessionCreateWithoutUserInput, SpeakingSessionUncheckedCreateWithoutUserInput> | SpeakingSessionCreateWithoutUserInput[] | SpeakingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpeakingSessionCreateOrConnectWithoutUserInput | SpeakingSessionCreateOrConnectWithoutUserInput[]
    upsert?: SpeakingSessionUpsertWithWhereUniqueWithoutUserInput | SpeakingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SpeakingSessionCreateManyUserInputEnvelope
    set?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    disconnect?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    delete?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    connect?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    update?: SpeakingSessionUpdateWithWhereUniqueWithoutUserInput | SpeakingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SpeakingSessionUpdateManyWithWhereWithoutUserInput | SpeakingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SpeakingSessionScalarWhereInput | SpeakingSessionScalarWhereInput[]
  }

  export type ListeningSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListeningSessionCreateWithoutUserInput, ListeningSessionUncheckedCreateWithoutUserInput> | ListeningSessionCreateWithoutUserInput[] | ListeningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningSessionCreateOrConnectWithoutUserInput | ListeningSessionCreateOrConnectWithoutUserInput[]
    upsert?: ListeningSessionUpsertWithWhereUniqueWithoutUserInput | ListeningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListeningSessionCreateManyUserInputEnvelope
    set?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    disconnect?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    delete?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    connect?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    update?: ListeningSessionUpdateWithWhereUniqueWithoutUserInput | ListeningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListeningSessionUpdateManyWithWhereWithoutUserInput | ListeningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListeningSessionScalarWhereInput | ListeningSessionScalarWhereInput[]
  }

  export type PlacementTestUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlacementTestCreateWithoutUserInput, PlacementTestUncheckedCreateWithoutUserInput> | PlacementTestCreateWithoutUserInput[] | PlacementTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlacementTestCreateOrConnectWithoutUserInput | PlacementTestCreateOrConnectWithoutUserInput[]
    upsert?: PlacementTestUpsertWithWhereUniqueWithoutUserInput | PlacementTestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlacementTestCreateManyUserInputEnvelope
    set?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    disconnect?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    delete?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    connect?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    update?: PlacementTestUpdateWithWhereUniqueWithoutUserInput | PlacementTestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlacementTestUpdateManyWithWhereWithoutUserInput | PlacementTestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlacementTestScalarWhereInput | PlacementTestScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type GamificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GamificationCreateWithoutUserInput, GamificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: GamificationCreateOrConnectWithoutUserInput
    upsert?: GamificationUpsertWithoutUserInput
    disconnect?: GamificationWhereInput | boolean
    delete?: GamificationWhereInput | boolean
    connect?: GamificationWhereUniqueInput
    update?: XOR<XOR<GamificationUpdateToOneWithWhereWithoutUserInput, GamificationUpdateWithoutUserInput>, GamificationUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LessonCreateWithoutStudentInput, LessonUncheckedCreateWithoutStudentInput> | LessonCreateWithoutStudentInput[] | LessonUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentInput | LessonCreateOrConnectWithoutStudentInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutStudentInput | LessonUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LessonCreateManyStudentInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutStudentInput | LessonUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutStudentInput | LessonUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SpeakingSessionCreateWithoutUserInput, SpeakingSessionUncheckedCreateWithoutUserInput> | SpeakingSessionCreateWithoutUserInput[] | SpeakingSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SpeakingSessionCreateOrConnectWithoutUserInput | SpeakingSessionCreateOrConnectWithoutUserInput[]
    upsert?: SpeakingSessionUpsertWithWhereUniqueWithoutUserInput | SpeakingSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SpeakingSessionCreateManyUserInputEnvelope
    set?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    disconnect?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    delete?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    connect?: SpeakingSessionWhereUniqueInput | SpeakingSessionWhereUniqueInput[]
    update?: SpeakingSessionUpdateWithWhereUniqueWithoutUserInput | SpeakingSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SpeakingSessionUpdateManyWithWhereWithoutUserInput | SpeakingSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SpeakingSessionScalarWhereInput | SpeakingSessionScalarWhereInput[]
  }

  export type ListeningSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListeningSessionCreateWithoutUserInput, ListeningSessionUncheckedCreateWithoutUserInput> | ListeningSessionCreateWithoutUserInput[] | ListeningSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListeningSessionCreateOrConnectWithoutUserInput | ListeningSessionCreateOrConnectWithoutUserInput[]
    upsert?: ListeningSessionUpsertWithWhereUniqueWithoutUserInput | ListeningSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListeningSessionCreateManyUserInputEnvelope
    set?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    disconnect?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    delete?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    connect?: ListeningSessionWhereUniqueInput | ListeningSessionWhereUniqueInput[]
    update?: ListeningSessionUpdateWithWhereUniqueWithoutUserInput | ListeningSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListeningSessionUpdateManyWithWhereWithoutUserInput | ListeningSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListeningSessionScalarWhereInput | ListeningSessionScalarWhereInput[]
  }

  export type PlacementTestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlacementTestCreateWithoutUserInput, PlacementTestUncheckedCreateWithoutUserInput> | PlacementTestCreateWithoutUserInput[] | PlacementTestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlacementTestCreateOrConnectWithoutUserInput | PlacementTestCreateOrConnectWithoutUserInput[]
    upsert?: PlacementTestUpsertWithWhereUniqueWithoutUserInput | PlacementTestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlacementTestCreateManyUserInputEnvelope
    set?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    disconnect?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    delete?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    connect?: PlacementTestWhereUniqueInput | PlacementTestWhereUniqueInput[]
    update?: PlacementTestUpdateWithWhereUniqueWithoutUserInput | PlacementTestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlacementTestUpdateManyWithWhereWithoutUserInput | PlacementTestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlacementTestScalarWhereInput | PlacementTestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGamificationInput = {
    create?: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutGamificationInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutGamificationNestedInput = {
    create?: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutGamificationInput
    upsert?: UserUpsertWithoutGamificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGamificationInput, UserUpdateWithoutGamificationInput>, UserUncheckedUpdateWithoutGamificationInput>
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    upsert?: AchievementUpsertWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserAchievementsInput, AchievementUpdateWithoutUserAchievementsInput>, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type PhraseCreateNestedManyWithoutLevelInput = {
    create?: XOR<PhraseCreateWithoutLevelInput, PhraseUncheckedCreateWithoutLevelInput> | PhraseCreateWithoutLevelInput[] | PhraseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutLevelInput | PhraseCreateOrConnectWithoutLevelInput[]
    createMany?: PhraseCreateManyLevelInputEnvelope
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
  }

  export type PhraseUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<PhraseCreateWithoutLevelInput, PhraseUncheckedCreateWithoutLevelInput> | PhraseCreateWithoutLevelInput[] | PhraseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutLevelInput | PhraseCreateOrConnectWithoutLevelInput[]
    createMany?: PhraseCreateManyLevelInputEnvelope
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
  }

  export type PhraseUpdateManyWithoutLevelNestedInput = {
    create?: XOR<PhraseCreateWithoutLevelInput, PhraseUncheckedCreateWithoutLevelInput> | PhraseCreateWithoutLevelInput[] | PhraseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutLevelInput | PhraseCreateOrConnectWithoutLevelInput[]
    upsert?: PhraseUpsertWithWhereUniqueWithoutLevelInput | PhraseUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: PhraseCreateManyLevelInputEnvelope
    set?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    disconnect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    delete?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    update?: PhraseUpdateWithWhereUniqueWithoutLevelInput | PhraseUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: PhraseUpdateManyWithWhereWithoutLevelInput | PhraseUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
  }

  export type PhraseUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<PhraseCreateWithoutLevelInput, PhraseUncheckedCreateWithoutLevelInput> | PhraseCreateWithoutLevelInput[] | PhraseUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutLevelInput | PhraseCreateOrConnectWithoutLevelInput[]
    upsert?: PhraseUpsertWithWhereUniqueWithoutLevelInput | PhraseUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: PhraseCreateManyLevelInputEnvelope
    set?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    disconnect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    delete?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    update?: PhraseUpdateWithWhereUniqueWithoutLevelInput | PhraseUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: PhraseUpdateManyWithWhereWithoutLevelInput | PhraseUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
  }

  export type PhraseCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PhraseCreateWithoutCategoryInput, PhraseUncheckedCreateWithoutCategoryInput> | PhraseCreateWithoutCategoryInput[] | PhraseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutCategoryInput | PhraseCreateOrConnectWithoutCategoryInput[]
    createMany?: PhraseCreateManyCategoryInputEnvelope
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
  }

  export type PhraseUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PhraseCreateWithoutCategoryInput, PhraseUncheckedCreateWithoutCategoryInput> | PhraseCreateWithoutCategoryInput[] | PhraseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutCategoryInput | PhraseCreateOrConnectWithoutCategoryInput[]
    createMany?: PhraseCreateManyCategoryInputEnvelope
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
  }

  export type PhraseUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PhraseCreateWithoutCategoryInput, PhraseUncheckedCreateWithoutCategoryInput> | PhraseCreateWithoutCategoryInput[] | PhraseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutCategoryInput | PhraseCreateOrConnectWithoutCategoryInput[]
    upsert?: PhraseUpsertWithWhereUniqueWithoutCategoryInput | PhraseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PhraseCreateManyCategoryInputEnvelope
    set?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    disconnect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    delete?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    update?: PhraseUpdateWithWhereUniqueWithoutCategoryInput | PhraseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PhraseUpdateManyWithWhereWithoutCategoryInput | PhraseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
  }

  export type PhraseUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PhraseCreateWithoutCategoryInput, PhraseUncheckedCreateWithoutCategoryInput> | PhraseCreateWithoutCategoryInput[] | PhraseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PhraseCreateOrConnectWithoutCategoryInput | PhraseCreateOrConnectWithoutCategoryInput[]
    upsert?: PhraseUpsertWithWhereUniqueWithoutCategoryInput | PhraseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PhraseCreateManyCategoryInputEnvelope
    set?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    disconnect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    delete?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    connect?: PhraseWhereUniqueInput | PhraseWhereUniqueInput[]
    update?: PhraseUpdateWithWhereUniqueWithoutCategoryInput | PhraseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PhraseUpdateManyWithWhereWithoutCategoryInput | PhraseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
  }

  export type PhraseCreatetagsInput = {
    set: string[]
  }

  export type LevelCreateNestedOneWithoutPhrasesInput = {
    create?: XOR<LevelCreateWithoutPhrasesInput, LevelUncheckedCreateWithoutPhrasesInput>
    connectOrCreate?: LevelCreateOrConnectWithoutPhrasesInput
    connect?: LevelWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutPhrasesInput = {
    create?: XOR<CategoryCreateWithoutPhrasesInput, CategoryUncheckedCreateWithoutPhrasesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPhrasesInput
    connect?: CategoryWhereUniqueInput
  }

  export type UserProgressCreateNestedManyWithoutPhraseInput = {
    create?: XOR<UserProgressCreateWithoutPhraseInput, UserProgressUncheckedCreateWithoutPhraseInput> | UserProgressCreateWithoutPhraseInput[] | UserProgressUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPhraseInput | UserProgressCreateOrConnectWithoutPhraseInput[]
    createMany?: UserProgressCreateManyPhraseInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type SpeakingAttemptCreateNestedManyWithoutPhraseInput = {
    create?: XOR<SpeakingAttemptCreateWithoutPhraseInput, SpeakingAttemptUncheckedCreateWithoutPhraseInput> | SpeakingAttemptCreateWithoutPhraseInput[] | SpeakingAttemptUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutPhraseInput | SpeakingAttemptCreateOrConnectWithoutPhraseInput[]
    createMany?: SpeakingAttemptCreateManyPhraseInputEnvelope
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutPhraseInput = {
    create?: XOR<UserProgressCreateWithoutPhraseInput, UserProgressUncheckedCreateWithoutPhraseInput> | UserProgressCreateWithoutPhraseInput[] | UserProgressUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPhraseInput | UserProgressCreateOrConnectWithoutPhraseInput[]
    createMany?: UserProgressCreateManyPhraseInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type SpeakingAttemptUncheckedCreateNestedManyWithoutPhraseInput = {
    create?: XOR<SpeakingAttemptCreateWithoutPhraseInput, SpeakingAttemptUncheckedCreateWithoutPhraseInput> | SpeakingAttemptCreateWithoutPhraseInput[] | SpeakingAttemptUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutPhraseInput | SpeakingAttemptCreateOrConnectWithoutPhraseInput[]
    createMany?: SpeakingAttemptCreateManyPhraseInputEnvelope
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
  }

  export type PhraseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LevelUpdateOneRequiredWithoutPhrasesNestedInput = {
    create?: XOR<LevelCreateWithoutPhrasesInput, LevelUncheckedCreateWithoutPhrasesInput>
    connectOrCreate?: LevelCreateOrConnectWithoutPhrasesInput
    upsert?: LevelUpsertWithoutPhrasesInput
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutPhrasesInput, LevelUpdateWithoutPhrasesInput>, LevelUncheckedUpdateWithoutPhrasesInput>
  }

  export type CategoryUpdateOneRequiredWithoutPhrasesNestedInput = {
    create?: XOR<CategoryCreateWithoutPhrasesInput, CategoryUncheckedCreateWithoutPhrasesInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPhrasesInput
    upsert?: CategoryUpsertWithoutPhrasesInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPhrasesInput, CategoryUpdateWithoutPhrasesInput>, CategoryUncheckedUpdateWithoutPhrasesInput>
  }

  export type UserProgressUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<UserProgressCreateWithoutPhraseInput, UserProgressUncheckedCreateWithoutPhraseInput> | UserProgressCreateWithoutPhraseInput[] | UserProgressUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPhraseInput | UserProgressCreateOrConnectWithoutPhraseInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutPhraseInput | UserProgressUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: UserProgressCreateManyPhraseInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutPhraseInput | UserProgressUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutPhraseInput | UserProgressUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type SpeakingAttemptUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<SpeakingAttemptCreateWithoutPhraseInput, SpeakingAttemptUncheckedCreateWithoutPhraseInput> | SpeakingAttemptCreateWithoutPhraseInput[] | SpeakingAttemptUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutPhraseInput | SpeakingAttemptCreateOrConnectWithoutPhraseInput[]
    upsert?: SpeakingAttemptUpsertWithWhereUniqueWithoutPhraseInput | SpeakingAttemptUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: SpeakingAttemptCreateManyPhraseInputEnvelope
    set?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    disconnect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    delete?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    update?: SpeakingAttemptUpdateWithWhereUniqueWithoutPhraseInput | SpeakingAttemptUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: SpeakingAttemptUpdateManyWithWhereWithoutPhraseInput | SpeakingAttemptUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: SpeakingAttemptScalarWhereInput | SpeakingAttemptScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<UserProgressCreateWithoutPhraseInput, UserProgressUncheckedCreateWithoutPhraseInput> | UserProgressCreateWithoutPhraseInput[] | UserProgressUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutPhraseInput | UserProgressCreateOrConnectWithoutPhraseInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutPhraseInput | UserProgressUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: UserProgressCreateManyPhraseInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutPhraseInput | UserProgressUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutPhraseInput | UserProgressUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type SpeakingAttemptUncheckedUpdateManyWithoutPhraseNestedInput = {
    create?: XOR<SpeakingAttemptCreateWithoutPhraseInput, SpeakingAttemptUncheckedCreateWithoutPhraseInput> | SpeakingAttemptCreateWithoutPhraseInput[] | SpeakingAttemptUncheckedCreateWithoutPhraseInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutPhraseInput | SpeakingAttemptCreateOrConnectWithoutPhraseInput[]
    upsert?: SpeakingAttemptUpsertWithWhereUniqueWithoutPhraseInput | SpeakingAttemptUpsertWithWhereUniqueWithoutPhraseInput[]
    createMany?: SpeakingAttemptCreateManyPhraseInputEnvelope
    set?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    disconnect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    delete?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    update?: SpeakingAttemptUpdateWithWhereUniqueWithoutPhraseInput | SpeakingAttemptUpdateWithWhereUniqueWithoutPhraseInput[]
    updateMany?: SpeakingAttemptUpdateManyWithWhereWithoutPhraseInput | SpeakingAttemptUpdateManyWithWhereWithoutPhraseInput[]
    deleteMany?: SpeakingAttemptScalarWhereInput | SpeakingAttemptScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProgressInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    connect?: UserWhereUniqueInput
  }

  export type PhraseCreateNestedOneWithoutProgressInput = {
    create?: XOR<PhraseCreateWithoutProgressInput, PhraseUncheckedCreateWithoutProgressInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutProgressInput
    connect?: PhraseWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    upsert?: UserUpsertWithoutProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressInput, UserUpdateWithoutProgressInput>, UserUncheckedUpdateWithoutProgressInput>
  }

  export type PhraseUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<PhraseCreateWithoutProgressInput, PhraseUncheckedCreateWithoutProgressInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutProgressInput
    upsert?: PhraseUpsertWithoutProgressInput
    connect?: PhraseWhereUniqueInput
    update?: XOR<XOR<PhraseUpdateToOneWithWhereWithoutProgressInput, PhraseUpdateWithoutProgressInput>, PhraseUncheckedUpdateWithoutProgressInput>
  }

  export type UserCreateNestedOneWithoutSpeakingSessionsInput = {
    create?: XOR<UserCreateWithoutSpeakingSessionsInput, UserUncheckedCreateWithoutSpeakingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpeakingSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type SpeakingAttemptCreateNestedManyWithoutSessionInput = {
    create?: XOR<SpeakingAttemptCreateWithoutSessionInput, SpeakingAttemptUncheckedCreateWithoutSessionInput> | SpeakingAttemptCreateWithoutSessionInput[] | SpeakingAttemptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutSessionInput | SpeakingAttemptCreateOrConnectWithoutSessionInput[]
    createMany?: SpeakingAttemptCreateManySessionInputEnvelope
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
  }

  export type SpeakingAttemptUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SpeakingAttemptCreateWithoutSessionInput, SpeakingAttemptUncheckedCreateWithoutSessionInput> | SpeakingAttemptCreateWithoutSessionInput[] | SpeakingAttemptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutSessionInput | SpeakingAttemptCreateOrConnectWithoutSessionInput[]
    createMany?: SpeakingAttemptCreateManySessionInputEnvelope
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSpeakingSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSpeakingSessionsInput, UserUncheckedCreateWithoutSpeakingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSpeakingSessionsInput
    upsert?: UserUpsertWithoutSpeakingSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSpeakingSessionsInput, UserUpdateWithoutSpeakingSessionsInput>, UserUncheckedUpdateWithoutSpeakingSessionsInput>
  }

  export type SpeakingAttemptUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SpeakingAttemptCreateWithoutSessionInput, SpeakingAttemptUncheckedCreateWithoutSessionInput> | SpeakingAttemptCreateWithoutSessionInput[] | SpeakingAttemptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutSessionInput | SpeakingAttemptCreateOrConnectWithoutSessionInput[]
    upsert?: SpeakingAttemptUpsertWithWhereUniqueWithoutSessionInput | SpeakingAttemptUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SpeakingAttemptCreateManySessionInputEnvelope
    set?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    disconnect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    delete?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    update?: SpeakingAttemptUpdateWithWhereUniqueWithoutSessionInput | SpeakingAttemptUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SpeakingAttemptUpdateManyWithWhereWithoutSessionInput | SpeakingAttemptUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SpeakingAttemptScalarWhereInput | SpeakingAttemptScalarWhereInput[]
  }

  export type SpeakingAttemptUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SpeakingAttemptCreateWithoutSessionInput, SpeakingAttemptUncheckedCreateWithoutSessionInput> | SpeakingAttemptCreateWithoutSessionInput[] | SpeakingAttemptUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SpeakingAttemptCreateOrConnectWithoutSessionInput | SpeakingAttemptCreateOrConnectWithoutSessionInput[]
    upsert?: SpeakingAttemptUpsertWithWhereUniqueWithoutSessionInput | SpeakingAttemptUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SpeakingAttemptCreateManySessionInputEnvelope
    set?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    disconnect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    delete?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    connect?: SpeakingAttemptWhereUniqueInput | SpeakingAttemptWhereUniqueInput[]
    update?: SpeakingAttemptUpdateWithWhereUniqueWithoutSessionInput | SpeakingAttemptUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SpeakingAttemptUpdateManyWithWhereWithoutSessionInput | SpeakingAttemptUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SpeakingAttemptScalarWhereInput | SpeakingAttemptScalarWhereInput[]
  }

  export type SpeakingSessionCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<SpeakingSessionCreateWithoutAttemptsInput, SpeakingSessionUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: SpeakingSessionCreateOrConnectWithoutAttemptsInput
    connect?: SpeakingSessionWhereUniqueInput
  }

  export type PhraseCreateNestedOneWithoutSpeakingAttemptsInput = {
    create?: XOR<PhraseCreateWithoutSpeakingAttemptsInput, PhraseUncheckedCreateWithoutSpeakingAttemptsInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutSpeakingAttemptsInput
    connect?: PhraseWhereUniqueInput
  }

  export type SpeakingSessionUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<SpeakingSessionCreateWithoutAttemptsInput, SpeakingSessionUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: SpeakingSessionCreateOrConnectWithoutAttemptsInput
    upsert?: SpeakingSessionUpsertWithoutAttemptsInput
    connect?: SpeakingSessionWhereUniqueInput
    update?: XOR<XOR<SpeakingSessionUpdateToOneWithWhereWithoutAttemptsInput, SpeakingSessionUpdateWithoutAttemptsInput>, SpeakingSessionUncheckedUpdateWithoutAttemptsInput>
  }

  export type PhraseUpdateOneRequiredWithoutSpeakingAttemptsNestedInput = {
    create?: XOR<PhraseCreateWithoutSpeakingAttemptsInput, PhraseUncheckedCreateWithoutSpeakingAttemptsInput>
    connectOrCreate?: PhraseCreateOrConnectWithoutSpeakingAttemptsInput
    upsert?: PhraseUpsertWithoutSpeakingAttemptsInput
    connect?: PhraseWhereUniqueInput
    update?: XOR<XOR<PhraseUpdateToOneWithWhereWithoutSpeakingAttemptsInput, PhraseUpdateWithoutSpeakingAttemptsInput>, PhraseUncheckedUpdateWithoutSpeakingAttemptsInput>
  }

  export type UserCreateNestedOneWithoutListeningSessionsInput = {
    create?: XOR<UserCreateWithoutListeningSessionsInput, UserUncheckedCreateWithoutListeningSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListeningSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutListeningSessionsNestedInput = {
    create?: XOR<UserCreateWithoutListeningSessionsInput, UserUncheckedCreateWithoutListeningSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListeningSessionsInput
    upsert?: UserUpsertWithoutListeningSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListeningSessionsInput, UserUpdateWithoutListeningSessionsInput>, UserUncheckedUpdateWithoutListeningSessionsInput>
  }

  export type UserCreateNestedOneWithoutPlacementTestsInput = {
    create?: XOR<UserCreateWithoutPlacementTestsInput, UserUncheckedCreateWithoutPlacementTestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacementTestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPlacementTestsNestedInput = {
    create?: XOR<UserCreateWithoutPlacementTestsInput, UserUncheckedCreateWithoutPlacementTestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacementTestsInput
    upsert?: UserUpsertWithoutPlacementTestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlacementTestsInput, UserUpdateWithoutPlacementTestsInput>, UserUncheckedUpdateWithoutPlacementTestsInput>
  }

  export type TeacherCreatecertificationsInput = {
    set: string[]
  }

  export type TeacherCreatespecializationsInput = {
    set: string[]
  }

  export type TeacherCreatelanguagesInput = {
    set: string[]
  }

  export type LessonCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type TeacherUpdatecertificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeacherUpdatespecializationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeacherUpdatelanguagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type LessonUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutTeacherInput | LessonUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutTeacherInput | LessonUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutTeacherInput | LessonUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutTeacherInput | LessonUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutTeacherInput | LessonUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutTeacherInput | LessonUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLessonsInput = {
    create?: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonsInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutLessonsInput = {
    create?: XOR<TeacherCreateWithoutLessonsInput, TeacherUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutLessonsInput
    connect?: TeacherWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonsInput
    upsert?: UserUpsertWithoutLessonsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLessonsInput, UserUpdateWithoutLessonsInput>, UserUncheckedUpdateWithoutLessonsInput>
  }

  export type TeacherUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<TeacherCreateWithoutLessonsInput, TeacherUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutLessonsInput
    upsert?: TeacherUpsertWithoutLessonsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutLessonsInput, TeacherUpdateWithoutLessonsInput>, TeacherUncheckedUpdateWithoutLessonsInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserProgressCreateWithoutUserInput = {
    id?: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    phrase: PhraseCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutUserInput = {
    id?: string
    phraseId: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressCreateManyUserInputEnvelope = {
    data: UserProgressCreateManyUserInput | UserProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GamificationCreateWithoutUserInput = {
    id?: string
    xp?: number
    level?: number
    xpToNextLevel?: number
    coins?: number
    gems?: number
    streak?: number
    maxStreak?: number
    lastActiveDate?: Date | string
    rank?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamificationUncheckedCreateWithoutUserInput = {
    id?: string
    xp?: number
    level?: number
    xpToNextLevel?: number
    coins?: number
    gems?: number
    streak?: number
    maxStreak?: number
    lastActiveDate?: Date | string
    rank?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GamificationCreateOrConnectWithoutUserInput = {
    where: GamificationWhereUniqueInput
    create: XOR<GamificationCreateWithoutUserInput, GamificationUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutStudentInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutStudentInput = {
    id?: string
    teacherId: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateOrConnectWithoutStudentInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutStudentInput, LessonUncheckedCreateWithoutStudentInput>
  }

  export type LessonCreateManyStudentInputEnvelope = {
    data: LessonCreateManyStudentInput | LessonCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SpeakingSessionCreateWithoutUserInput = {
    id?: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
    attempts?: SpeakingAttemptCreateNestedManyWithoutSessionInput
  }

  export type SpeakingSessionUncheckedCreateWithoutUserInput = {
    id?: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
    attempts?: SpeakingAttemptUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SpeakingSessionCreateOrConnectWithoutUserInput = {
    where: SpeakingSessionWhereUniqueInput
    create: XOR<SpeakingSessionCreateWithoutUserInput, SpeakingSessionUncheckedCreateWithoutUserInput>
  }

  export type SpeakingSessionCreateManyUserInputEnvelope = {
    data: SpeakingSessionCreateManyUserInput | SpeakingSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ListeningSessionCreateWithoutUserInput = {
    id?: string
    exerciseType: string
    accent: string
    speed: number
    exercises: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    score?: number
    timeSpent?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ListeningSessionUncheckedCreateWithoutUserInput = {
    id?: string
    exerciseType: string
    accent: string
    speed: number
    exercises: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    score?: number
    timeSpent?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ListeningSessionCreateOrConnectWithoutUserInput = {
    where: ListeningSessionWhereUniqueInput
    create: XOR<ListeningSessionCreateWithoutUserInput, ListeningSessionUncheckedCreateWithoutUserInput>
  }

  export type ListeningSessionCreateManyUserInputEnvelope = {
    data: ListeningSessionCreateManyUserInput | ListeningSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PlacementTestCreateWithoutUserInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    theta: number
    standardError: number
    level: string
    score: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PlacementTestUncheckedCreateWithoutUserInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    theta: number
    standardError: number
    level: string
    score: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PlacementTestCreateOrConnectWithoutUserInput = {
    where: PlacementTestWhereUniqueInput
    create: XOR<PlacementTestCreateWithoutUserInput, PlacementTestUncheckedCreateWithoutUserInput>
  }

  export type PlacementTestCreateManyUserInputEnvelope = {
    data: PlacementTestCreateManyUserInput | PlacementTestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProgressScalarWhereInput = {
    AND?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    OR?: UserProgressScalarWhereInput[]
    NOT?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    phraseId?: StringFilter<"UserProgress"> | string
    mastery?: IntFilter<"UserProgress"> | number
    attempts?: IntFilter<"UserProgress"> | number
    successes?: IntFilter<"UserProgress"> | number
    lastScore?: IntFilter<"UserProgress"> | number
    bestScore?: IntFilter<"UserProgress"> | number
    easeFactor?: FloatFilter<"UserProgress"> | number
    interval?: IntFilter<"UserProgress"> | number
    nextReview?: DateTimeFilter<"UserProgress"> | Date | string
    lastPracticed?: DateTimeFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
  }

  export type GamificationUpsertWithoutUserInput = {
    update: XOR<GamificationUpdateWithoutUserInput, GamificationUncheckedUpdateWithoutUserInput>
    create: XOR<GamificationCreateWithoutUserInput, GamificationUncheckedCreateWithoutUserInput>
    where?: GamificationWhereInput
  }

  export type GamificationUpdateToOneWithWhereWithoutUserInput = {
    where?: GamificationWhereInput
    data: XOR<GamificationUpdateWithoutUserInput, GamificationUncheckedUpdateWithoutUserInput>
  }

  export type GamificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rank?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GamificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    xpToNextLevel?: IntFieldUpdateOperationsInput | number
    coins?: IntFieldUpdateOperationsInput | number
    gems?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rank?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    progress?: IntFilter<"UserAchievement"> | number
    unlocked?: BoolFilter<"UserAchievement"> | boolean
    unlockedAt?: DateTimeNullableFilter<"UserAchievement"> | Date | string | null
    createdAt?: DateTimeFilter<"UserAchievement"> | Date | string
    updatedAt?: DateTimeFilter<"UserAchievement"> | Date | string
  }

  export type LessonUpsertWithWhereUniqueWithoutStudentInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutStudentInput, LessonUncheckedUpdateWithoutStudentInput>
    create: XOR<LessonCreateWithoutStudentInput, LessonUncheckedCreateWithoutStudentInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutStudentInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutStudentInput, LessonUncheckedUpdateWithoutStudentInput>
  }

  export type LessonUpdateManyWithWhereWithoutStudentInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutStudentInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    studentId?: StringFilter<"Lesson"> | string
    teacherId?: StringFilter<"Lesson"> | string
    scheduledAt?: DateTimeFilter<"Lesson"> | Date | string
    duration?: IntFilter<"Lesson"> | number
    status?: StringFilter<"Lesson"> | string
    meetingUrl?: StringNullableFilter<"Lesson"> | string | null
    notes?: StringNullableFilter<"Lesson"> | string | null
    feedback?: StringNullableFilter<"Lesson"> | string | null
    price?: IntFilter<"Lesson"> | number
    paid?: BoolFilter<"Lesson"> | boolean
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: IntFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeInvoiceId?: StringNullableFilter<"Payment"> | string | null
    description?: StringFilter<"Payment"> | string
    metadata?: JsonNullableFilter<"Payment">
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type SpeakingSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SpeakingSessionWhereUniqueInput
    update: XOR<SpeakingSessionUpdateWithoutUserInput, SpeakingSessionUncheckedUpdateWithoutUserInput>
    create: XOR<SpeakingSessionCreateWithoutUserInput, SpeakingSessionUncheckedCreateWithoutUserInput>
  }

  export type SpeakingSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SpeakingSessionWhereUniqueInput
    data: XOR<SpeakingSessionUpdateWithoutUserInput, SpeakingSessionUncheckedUpdateWithoutUserInput>
  }

  export type SpeakingSessionUpdateManyWithWhereWithoutUserInput = {
    where: SpeakingSessionScalarWhereInput
    data: XOR<SpeakingSessionUpdateManyMutationInput, SpeakingSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SpeakingSessionScalarWhereInput = {
    AND?: SpeakingSessionScalarWhereInput | SpeakingSessionScalarWhereInput[]
    OR?: SpeakingSessionScalarWhereInput[]
    NOT?: SpeakingSessionScalarWhereInput | SpeakingSessionScalarWhereInput[]
    id?: StringFilter<"SpeakingSession"> | string
    userId?: StringFilter<"SpeakingSession"> | string
    bestScore?: IntFilter<"SpeakingSession"> | number
    startedAt?: DateTimeFilter<"SpeakingSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"SpeakingSession"> | Date | string | null
    totalTime?: IntFilter<"SpeakingSession"> | number
  }

  export type ListeningSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ListeningSessionWhereUniqueInput
    update: XOR<ListeningSessionUpdateWithoutUserInput, ListeningSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ListeningSessionCreateWithoutUserInput, ListeningSessionUncheckedCreateWithoutUserInput>
  }

  export type ListeningSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ListeningSessionWhereUniqueInput
    data: XOR<ListeningSessionUpdateWithoutUserInput, ListeningSessionUncheckedUpdateWithoutUserInput>
  }

  export type ListeningSessionUpdateManyWithWhereWithoutUserInput = {
    where: ListeningSessionScalarWhereInput
    data: XOR<ListeningSessionUpdateManyMutationInput, ListeningSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ListeningSessionScalarWhereInput = {
    AND?: ListeningSessionScalarWhereInput | ListeningSessionScalarWhereInput[]
    OR?: ListeningSessionScalarWhereInput[]
    NOT?: ListeningSessionScalarWhereInput | ListeningSessionScalarWhereInput[]
    id?: StringFilter<"ListeningSession"> | string
    userId?: StringFilter<"ListeningSession"> | string
    exerciseType?: StringFilter<"ListeningSession"> | string
    accent?: StringFilter<"ListeningSession"> | string
    speed?: FloatFilter<"ListeningSession"> | number
    exercises?: JsonFilter<"ListeningSession">
    answers?: JsonFilter<"ListeningSession">
    score?: IntFilter<"ListeningSession"> | number
    timeSpent?: IntFilter<"ListeningSession"> | number
    completedAt?: DateTimeNullableFilter<"ListeningSession"> | Date | string | null
    createdAt?: DateTimeFilter<"ListeningSession"> | Date | string
  }

  export type PlacementTestUpsertWithWhereUniqueWithoutUserInput = {
    where: PlacementTestWhereUniqueInput
    update: XOR<PlacementTestUpdateWithoutUserInput, PlacementTestUncheckedUpdateWithoutUserInput>
    create: XOR<PlacementTestCreateWithoutUserInput, PlacementTestUncheckedCreateWithoutUserInput>
  }

  export type PlacementTestUpdateWithWhereUniqueWithoutUserInput = {
    where: PlacementTestWhereUniqueInput
    data: XOR<PlacementTestUpdateWithoutUserInput, PlacementTestUncheckedUpdateWithoutUserInput>
  }

  export type PlacementTestUpdateManyWithWhereWithoutUserInput = {
    where: PlacementTestScalarWhereInput
    data: XOR<PlacementTestUpdateManyMutationInput, PlacementTestUncheckedUpdateManyWithoutUserInput>
  }

  export type PlacementTestScalarWhereInput = {
    AND?: PlacementTestScalarWhereInput | PlacementTestScalarWhereInput[]
    OR?: PlacementTestScalarWhereInput[]
    NOT?: PlacementTestScalarWhereInput | PlacementTestScalarWhereInput[]
    id?: StringFilter<"PlacementTest"> | string
    userId?: StringFilter<"PlacementTest"> | string
    questions?: JsonFilter<"PlacementTest">
    answers?: JsonFilter<"PlacementTest">
    theta?: FloatFilter<"PlacementTest"> | number
    standardError?: FloatFilter<"PlacementTest"> | number
    level?: StringFilter<"PlacementTest"> | string
    score?: IntFilter<"PlacementTest"> | number
    completedAt?: DateTimeNullableFilter<"PlacementTest"> | Date | string | null
    createdAt?: DateTimeFilter<"PlacementTest"> | Date | string
  }

  export type UserCreateWithoutGamificationInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGamificationInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGamificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
  }

  export type UserUpsertWithoutGamificationInput = {
    update: XOR<UserUpdateWithoutGamificationInput, UserUncheckedUpdateWithoutGamificationInput>
    create: XOR<UserCreateWithoutGamificationInput, UserUncheckedCreateWithoutGamificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGamificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGamificationInput, UserUncheckedUpdateWithoutGamificationInput>
  }

  export type UserUpdateWithoutGamificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGamificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    gamification?: GamificationCreateNestedOneWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUserAchievementsInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: string
    xpReward?: number
    coinsReward?: number
    gemsReward?: number
    requirement: number
    isSecret?: boolean
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserAchievementsInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: string
    xpReward?: number
    coinsReward?: number
    gemsReward?: number
    requirement: number
    isSecret?: boolean
    createdAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserAchievementsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AchievementUpsertWithoutUserAchievementsInput = {
    update: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    coinsReward?: IntFieldUpdateOperationsInput | number
    gemsReward?: IntFieldUpdateOperationsInput | number
    requirement?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    xpReward?: IntFieldUpdateOperationsInput | number
    coinsReward?: IntFieldUpdateOperationsInput | number
    gemsReward?: IntFieldUpdateOperationsInput | number
    requirement?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseCreateWithoutLevelInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CategoryCreateNestedOneWithoutPhrasesInput
    progress?: UserProgressCreateNestedManyWithoutPhraseInput
    speakingAttempts?: SpeakingAttemptCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateWithoutLevelInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    categoryId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutPhraseInput
    speakingAttempts?: SpeakingAttemptUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseCreateOrConnectWithoutLevelInput = {
    where: PhraseWhereUniqueInput
    create: XOR<PhraseCreateWithoutLevelInput, PhraseUncheckedCreateWithoutLevelInput>
  }

  export type PhraseCreateManyLevelInputEnvelope = {
    data: PhraseCreateManyLevelInput | PhraseCreateManyLevelInput[]
    skipDuplicates?: boolean
  }

  export type PhraseUpsertWithWhereUniqueWithoutLevelInput = {
    where: PhraseWhereUniqueInput
    update: XOR<PhraseUpdateWithoutLevelInput, PhraseUncheckedUpdateWithoutLevelInput>
    create: XOR<PhraseCreateWithoutLevelInput, PhraseUncheckedCreateWithoutLevelInput>
  }

  export type PhraseUpdateWithWhereUniqueWithoutLevelInput = {
    where: PhraseWhereUniqueInput
    data: XOR<PhraseUpdateWithoutLevelInput, PhraseUncheckedUpdateWithoutLevelInput>
  }

  export type PhraseUpdateManyWithWhereWithoutLevelInput = {
    where: PhraseScalarWhereInput
    data: XOR<PhraseUpdateManyMutationInput, PhraseUncheckedUpdateManyWithoutLevelInput>
  }

  export type PhraseScalarWhereInput = {
    AND?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
    OR?: PhraseScalarWhereInput[]
    NOT?: PhraseScalarWhereInput | PhraseScalarWhereInput[]
    id?: StringFilter<"Phrase"> | string
    text?: StringFilter<"Phrase"> | string
    translation?: StringFilter<"Phrase"> | string
    audioUrl?: StringNullableFilter<"Phrase"> | string | null
    imageUrl?: StringNullableFilter<"Phrase"> | string | null
    levelId?: StringFilter<"Phrase"> | string
    categoryId?: StringFilter<"Phrase"> | string
    difficulty?: IntFilter<"Phrase"> | number
    tags?: StringNullableListFilter<"Phrase">
    ipaTranscription?: StringNullableFilter<"Phrase"> | string | null
    createdAt?: DateTimeFilter<"Phrase"> | Date | string
    updatedAt?: DateTimeFilter<"Phrase"> | Date | string
  }

  export type PhraseCreateWithoutCategoryInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level: LevelCreateNestedOneWithoutPhrasesInput
    progress?: UserProgressCreateNestedManyWithoutPhraseInput
    speakingAttempts?: SpeakingAttemptCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateWithoutCategoryInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    levelId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutPhraseInput
    speakingAttempts?: SpeakingAttemptUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseCreateOrConnectWithoutCategoryInput = {
    where: PhraseWhereUniqueInput
    create: XOR<PhraseCreateWithoutCategoryInput, PhraseUncheckedCreateWithoutCategoryInput>
  }

  export type PhraseCreateManyCategoryInputEnvelope = {
    data: PhraseCreateManyCategoryInput | PhraseCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PhraseUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PhraseWhereUniqueInput
    update: XOR<PhraseUpdateWithoutCategoryInput, PhraseUncheckedUpdateWithoutCategoryInput>
    create: XOR<PhraseCreateWithoutCategoryInput, PhraseUncheckedCreateWithoutCategoryInput>
  }

  export type PhraseUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PhraseWhereUniqueInput
    data: XOR<PhraseUpdateWithoutCategoryInput, PhraseUncheckedUpdateWithoutCategoryInput>
  }

  export type PhraseUpdateManyWithWhereWithoutCategoryInput = {
    where: PhraseScalarWhereInput
    data: XOR<PhraseUpdateManyMutationInput, PhraseUncheckedUpdateManyWithoutCategoryInput>
  }

  export type LevelCreateWithoutPhrasesInput = {
    id?: string
    name: string
    description: string
    order: number
    createdAt?: Date | string
  }

  export type LevelUncheckedCreateWithoutPhrasesInput = {
    id?: string
    name: string
    description: string
    order: number
    createdAt?: Date | string
  }

  export type LevelCreateOrConnectWithoutPhrasesInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutPhrasesInput, LevelUncheckedCreateWithoutPhrasesInput>
  }

  export type CategoryCreateWithoutPhrasesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutPhrasesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutPhrasesInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPhrasesInput, CategoryUncheckedCreateWithoutPhrasesInput>
  }

  export type UserProgressCreateWithoutPhraseInput = {
    id?: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutPhraseInput = {
    id?: string
    userId: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutPhraseInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutPhraseInput, UserProgressUncheckedCreateWithoutPhraseInput>
  }

  export type UserProgressCreateManyPhraseInputEnvelope = {
    data: UserProgressCreateManyPhraseInput | UserProgressCreateManyPhraseInput[]
    skipDuplicates?: boolean
  }

  export type SpeakingAttemptCreateWithoutPhraseInput = {
    id?: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    session: SpeakingSessionCreateNestedOneWithoutAttemptsInput
  }

  export type SpeakingAttemptUncheckedCreateWithoutPhraseInput = {
    id?: string
    sessionId: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SpeakingAttemptCreateOrConnectWithoutPhraseInput = {
    where: SpeakingAttemptWhereUniqueInput
    create: XOR<SpeakingAttemptCreateWithoutPhraseInput, SpeakingAttemptUncheckedCreateWithoutPhraseInput>
  }

  export type SpeakingAttemptCreateManyPhraseInputEnvelope = {
    data: SpeakingAttemptCreateManyPhraseInput | SpeakingAttemptCreateManyPhraseInput[]
    skipDuplicates?: boolean
  }

  export type LevelUpsertWithoutPhrasesInput = {
    update: XOR<LevelUpdateWithoutPhrasesInput, LevelUncheckedUpdateWithoutPhrasesInput>
    create: XOR<LevelCreateWithoutPhrasesInput, LevelUncheckedCreateWithoutPhrasesInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutPhrasesInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutPhrasesInput, LevelUncheckedUpdateWithoutPhrasesInput>
  }

  export type LevelUpdateWithoutPhrasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LevelUncheckedUpdateWithoutPhrasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUpsertWithoutPhrasesInput = {
    update: XOR<CategoryUpdateWithoutPhrasesInput, CategoryUncheckedUpdateWithoutPhrasesInput>
    create: XOR<CategoryCreateWithoutPhrasesInput, CategoryUncheckedCreateWithoutPhrasesInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPhrasesInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPhrasesInput, CategoryUncheckedUpdateWithoutPhrasesInput>
  }

  export type CategoryUpdateWithoutPhrasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutPhrasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUpsertWithWhereUniqueWithoutPhraseInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutPhraseInput, UserProgressUncheckedUpdateWithoutPhraseInput>
    create: XOR<UserProgressCreateWithoutPhraseInput, UserProgressUncheckedCreateWithoutPhraseInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutPhraseInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutPhraseInput, UserProgressUncheckedUpdateWithoutPhraseInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutPhraseInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutPhraseInput>
  }

  export type SpeakingAttemptUpsertWithWhereUniqueWithoutPhraseInput = {
    where: SpeakingAttemptWhereUniqueInput
    update: XOR<SpeakingAttemptUpdateWithoutPhraseInput, SpeakingAttemptUncheckedUpdateWithoutPhraseInput>
    create: XOR<SpeakingAttemptCreateWithoutPhraseInput, SpeakingAttemptUncheckedCreateWithoutPhraseInput>
  }

  export type SpeakingAttemptUpdateWithWhereUniqueWithoutPhraseInput = {
    where: SpeakingAttemptWhereUniqueInput
    data: XOR<SpeakingAttemptUpdateWithoutPhraseInput, SpeakingAttemptUncheckedUpdateWithoutPhraseInput>
  }

  export type SpeakingAttemptUpdateManyWithWhereWithoutPhraseInput = {
    where: SpeakingAttemptScalarWhereInput
    data: XOR<SpeakingAttemptUpdateManyMutationInput, SpeakingAttemptUncheckedUpdateManyWithoutPhraseInput>
  }

  export type SpeakingAttemptScalarWhereInput = {
    AND?: SpeakingAttemptScalarWhereInput | SpeakingAttemptScalarWhereInput[]
    OR?: SpeakingAttemptScalarWhereInput[]
    NOT?: SpeakingAttemptScalarWhereInput | SpeakingAttemptScalarWhereInput[]
    id?: StringFilter<"SpeakingAttempt"> | string
    sessionId?: StringFilter<"SpeakingAttempt"> | string
    phraseId?: StringFilter<"SpeakingAttempt"> | string
    audioUrl?: StringFilter<"SpeakingAttempt"> | string
    duration?: IntFilter<"SpeakingAttempt"> | number
    transcription?: StringFilter<"SpeakingAttempt"> | string
    overallScore?: IntFilter<"SpeakingAttempt"> | number
    accuracy?: IntFilter<"SpeakingAttempt"> | number
    fluency?: IntFilter<"SpeakingAttempt"> | number
    completeness?: IntFilter<"SpeakingAttempt"> | number
    prosody?: IntFilter<"SpeakingAttempt"> | number
    feedback?: JsonFilter<"SpeakingAttempt">
    mistakes?: JsonFilter<"SpeakingAttempt">
    phonemes?: JsonFilter<"SpeakingAttempt">
    createdAt?: DateTimeFilter<"SpeakingAttempt"> | Date | string
  }

  export type UserCreateWithoutProgressInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gamification?: GamificationCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProgressInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
  }

  export type PhraseCreateWithoutProgressInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level: LevelCreateNestedOneWithoutPhrasesInput
    category: CategoryCreateNestedOneWithoutPhrasesInput
    speakingAttempts?: SpeakingAttemptCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateWithoutProgressInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    levelId: string
    categoryId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    speakingAttempts?: SpeakingAttemptUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseCreateOrConnectWithoutProgressInput = {
    where: PhraseWhereUniqueInput
    create: XOR<PhraseCreateWithoutProgressInput, PhraseUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutProgressInput = {
    update: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
  }

  export type UserUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PhraseUpsertWithoutProgressInput = {
    update: XOR<PhraseUpdateWithoutProgressInput, PhraseUncheckedUpdateWithoutProgressInput>
    create: XOR<PhraseCreateWithoutProgressInput, PhraseUncheckedCreateWithoutProgressInput>
    where?: PhraseWhereInput
  }

  export type PhraseUpdateToOneWithWhereWithoutProgressInput = {
    where?: PhraseWhereInput
    data: XOR<PhraseUpdateWithoutProgressInput, PhraseUncheckedUpdateWithoutProgressInput>
  }

  export type PhraseUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: LevelUpdateOneRequiredWithoutPhrasesNestedInput
    category?: CategoryUpdateOneRequiredWithoutPhrasesNestedInput
    speakingAttempts?: SpeakingAttemptUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    speakingAttempts?: SpeakingAttemptUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type UserCreateWithoutSpeakingSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    gamification?: GamificationCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSpeakingSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSpeakingSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSpeakingSessionsInput, UserUncheckedCreateWithoutSpeakingSessionsInput>
  }

  export type SpeakingAttemptCreateWithoutSessionInput = {
    id?: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    phrase: PhraseCreateNestedOneWithoutSpeakingAttemptsInput
  }

  export type SpeakingAttemptUncheckedCreateWithoutSessionInput = {
    id?: string
    phraseId: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SpeakingAttemptCreateOrConnectWithoutSessionInput = {
    where: SpeakingAttemptWhereUniqueInput
    create: XOR<SpeakingAttemptCreateWithoutSessionInput, SpeakingAttemptUncheckedCreateWithoutSessionInput>
  }

  export type SpeakingAttemptCreateManySessionInputEnvelope = {
    data: SpeakingAttemptCreateManySessionInput | SpeakingAttemptCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSpeakingSessionsInput = {
    update: XOR<UserUpdateWithoutSpeakingSessionsInput, UserUncheckedUpdateWithoutSpeakingSessionsInput>
    create: XOR<UserCreateWithoutSpeakingSessionsInput, UserUncheckedCreateWithoutSpeakingSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSpeakingSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSpeakingSessionsInput, UserUncheckedUpdateWithoutSpeakingSessionsInput>
  }

  export type UserUpdateWithoutSpeakingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSpeakingSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SpeakingAttemptUpsertWithWhereUniqueWithoutSessionInput = {
    where: SpeakingAttemptWhereUniqueInput
    update: XOR<SpeakingAttemptUpdateWithoutSessionInput, SpeakingAttemptUncheckedUpdateWithoutSessionInput>
    create: XOR<SpeakingAttemptCreateWithoutSessionInput, SpeakingAttemptUncheckedCreateWithoutSessionInput>
  }

  export type SpeakingAttemptUpdateWithWhereUniqueWithoutSessionInput = {
    where: SpeakingAttemptWhereUniqueInput
    data: XOR<SpeakingAttemptUpdateWithoutSessionInput, SpeakingAttemptUncheckedUpdateWithoutSessionInput>
  }

  export type SpeakingAttemptUpdateManyWithWhereWithoutSessionInput = {
    where: SpeakingAttemptScalarWhereInput
    data: XOR<SpeakingAttemptUpdateManyMutationInput, SpeakingAttemptUncheckedUpdateManyWithoutSessionInput>
  }

  export type SpeakingSessionCreateWithoutAttemptsInput = {
    id?: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
    user: UserCreateNestedOneWithoutSpeakingSessionsInput
  }

  export type SpeakingSessionUncheckedCreateWithoutAttemptsInput = {
    id?: string
    userId: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
  }

  export type SpeakingSessionCreateOrConnectWithoutAttemptsInput = {
    where: SpeakingSessionWhereUniqueInput
    create: XOR<SpeakingSessionCreateWithoutAttemptsInput, SpeakingSessionUncheckedCreateWithoutAttemptsInput>
  }

  export type PhraseCreateWithoutSpeakingAttemptsInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    level: LevelCreateNestedOneWithoutPhrasesInput
    category: CategoryCreateNestedOneWithoutPhrasesInput
    progress?: UserProgressCreateNestedManyWithoutPhraseInput
  }

  export type PhraseUncheckedCreateWithoutSpeakingAttemptsInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    levelId: string
    categoryId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutPhraseInput
  }

  export type PhraseCreateOrConnectWithoutSpeakingAttemptsInput = {
    where: PhraseWhereUniqueInput
    create: XOR<PhraseCreateWithoutSpeakingAttemptsInput, PhraseUncheckedCreateWithoutSpeakingAttemptsInput>
  }

  export type SpeakingSessionUpsertWithoutAttemptsInput = {
    update: XOR<SpeakingSessionUpdateWithoutAttemptsInput, SpeakingSessionUncheckedUpdateWithoutAttemptsInput>
    create: XOR<SpeakingSessionCreateWithoutAttemptsInput, SpeakingSessionUncheckedCreateWithoutAttemptsInput>
    where?: SpeakingSessionWhereInput
  }

  export type SpeakingSessionUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: SpeakingSessionWhereInput
    data: XOR<SpeakingSessionUpdateWithoutAttemptsInput, SpeakingSessionUncheckedUpdateWithoutAttemptsInput>
  }

  export type SpeakingSessionUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutSpeakingSessionsNestedInput
  }

  export type SpeakingSessionUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type PhraseUpsertWithoutSpeakingAttemptsInput = {
    update: XOR<PhraseUpdateWithoutSpeakingAttemptsInput, PhraseUncheckedUpdateWithoutSpeakingAttemptsInput>
    create: XOR<PhraseCreateWithoutSpeakingAttemptsInput, PhraseUncheckedCreateWithoutSpeakingAttemptsInput>
    where?: PhraseWhereInput
  }

  export type PhraseUpdateToOneWithWhereWithoutSpeakingAttemptsInput = {
    where?: PhraseWhereInput
    data: XOR<PhraseUpdateWithoutSpeakingAttemptsInput, PhraseUncheckedUpdateWithoutSpeakingAttemptsInput>
  }

  export type PhraseUpdateWithoutSpeakingAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: LevelUpdateOneRequiredWithoutPhrasesNestedInput
    category?: CategoryUpdateOneRequiredWithoutPhrasesNestedInput
    progress?: UserProgressUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateWithoutSpeakingAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type UserCreateWithoutListeningSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    gamification?: GamificationCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutListeningSessionsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutListeningSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListeningSessionsInput, UserUncheckedCreateWithoutListeningSessionsInput>
  }

  export type UserUpsertWithoutListeningSessionsInput = {
    update: XOR<UserUpdateWithoutListeningSessionsInput, UserUncheckedUpdateWithoutListeningSessionsInput>
    create: XOR<UserCreateWithoutListeningSessionsInput, UserUncheckedCreateWithoutListeningSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListeningSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListeningSessionsInput, UserUncheckedUpdateWithoutListeningSessionsInput>
  }

  export type UserUpdateWithoutListeningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListeningSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPlacementTestsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    gamification?: GamificationCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlacementTestsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlacementTestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlacementTestsInput, UserUncheckedCreateWithoutPlacementTestsInput>
  }

  export type UserUpsertWithoutPlacementTestsInput = {
    update: XOR<UserUpdateWithoutPlacementTestsInput, UserUncheckedUpdateWithoutPlacementTestsInput>
    create: XOR<UserCreateWithoutPlacementTestsInput, UserUncheckedCreateWithoutPlacementTestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlacementTestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlacementTestsInput, UserUncheckedUpdateWithoutPlacementTestsInput>
  }

  export type UserUpdateWithoutPlacementTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlacementTestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LessonCreateWithoutTeacherInput = {
    id?: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: UserCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutTeacherInput = {
    id?: string
    studentId: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateOrConnectWithoutTeacherInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput>
  }

  export type LessonCreateManyTeacherInputEnvelope = {
    data: LessonCreateManyTeacherInput | LessonCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithWhereUniqueWithoutTeacherInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutTeacherInput, LessonUncheckedUpdateWithoutTeacherInput>
    create: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutTeacherInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutTeacherInput, LessonUncheckedUpdateWithoutTeacherInput>
  }

  export type LessonUpdateManyWithWhereWithoutTeacherInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutTeacherInput>
  }

  export type UserCreateWithoutLessonsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    gamification?: GamificationCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
  }

  export type TeacherCreateWithoutLessonsInput = {
    id?: string
    name: string
    email: string
    avatar?: string | null
    bio?: string | null
    certifications?: TeacherCreatecertificationsInput | string[]
    specializations?: TeacherCreatespecializationsInput | string[]
    languages?: TeacherCreatelanguagesInput | string[]
    rating?: number
    totalLessons?: number
    experience?: number
    hourlyRate: number
    timezone?: string
    availability: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUncheckedCreateWithoutLessonsInput = {
    id?: string
    name: string
    email: string
    avatar?: string | null
    bio?: string | null
    certifications?: TeacherCreatecertificationsInput | string[]
    specializations?: TeacherCreatespecializationsInput | string[]
    languages?: TeacherCreatelanguagesInput | string[]
    rating?: number
    totalLessons?: number
    experience?: number
    hourlyRate: number
    timezone?: string
    availability: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherCreateOrConnectWithoutLessonsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutLessonsInput, TeacherUncheckedCreateWithoutLessonsInput>
  }

  export type UserUpsertWithoutLessonsInput = {
    update: XOR<UserUpdateWithoutLessonsInput, UserUncheckedUpdateWithoutLessonsInput>
    create: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLessonsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLessonsInput, UserUncheckedUpdateWithoutLessonsInput>
  }

  export type UserUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeacherUpsertWithoutLessonsInput = {
    update: XOR<TeacherUpdateWithoutLessonsInput, TeacherUncheckedUpdateWithoutLessonsInput>
    create: XOR<TeacherCreateWithoutLessonsInput, TeacherUncheckedCreateWithoutLessonsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutLessonsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutLessonsInput, TeacherUncheckedUpdateWithoutLessonsInput>
  }

  export type TeacherUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: TeacherUpdatecertificationsInput | string[]
    specializations?: TeacherUpdatespecializationsInput | string[]
    languages?: TeacherUpdatelanguagesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    hourlyRate?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    availability?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    certifications?: TeacherUpdatecertificationsInput | string[]
    specializations?: TeacherUpdatespecializationsInput | string[]
    languages?: TeacherUpdatelanguagesInput | string[]
    rating?: FloatFieldUpdateOperationsInput | number
    totalLessons?: IntFieldUpdateOperationsInput | number
    experience?: IntFieldUpdateOperationsInput | number
    hourlyRate?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    availability?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    gamification?: GamificationCreateNestedOneWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    lessons?: LessonCreateNestedManyWithoutStudentInput
    speakingSessions?: SpeakingSessionCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password: string
    name: string
    avatar?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    country?: string
    timezone?: string
    level?: string
    emailVerified?: boolean
    refreshToken?: string | null
    lastLogin?: Date | string | null
    subscriptionStatus?: string
    subscriptionEndsAt?: Date | string | null
    stripeCustomerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    gamification?: GamificationUncheckedCreateNestedOneWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentInput
    speakingSessions?: SpeakingSessionUncheckedCreateNestedManyWithoutUserInput
    listeningSessions?: ListeningSessionUncheckedCreateNestedManyWithoutUserInput
    placementTests?: PlacementTestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    gamification?: GamificationUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    lessons?: LessonUpdateManyWithoutStudentNestedInput
    speakingSessions?: SpeakingSessionUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    gamification?: GamificationUncheckedUpdateOneWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentNestedInput
    speakingSessions?: SpeakingSessionUncheckedUpdateManyWithoutUserNestedInput
    listeningSessions?: ListeningSessionUncheckedUpdateManyWithoutUserNestedInput
    placementTests?: PlacementTestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserProgressCreateManyUserInput = {
    id?: string
    phraseId: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateManyStudentInput = {
    id?: string
    teacherId: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    amount: number
    currency?: string
    status: string
    stripePaymentIntentId?: string | null
    stripeInvoiceId?: string | null
    description: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpeakingSessionCreateManyUserInput = {
    id?: string
    bestScore?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    totalTime?: number
  }

  export type ListeningSessionCreateManyUserInput = {
    id?: string
    exerciseType: string
    accent: string
    speed: number
    exercises: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    score?: number
    timeSpent?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type PlacementTestCreateManyUserInput = {
    id?: string
    questions: JsonNullValueInput | InputJsonValue
    answers: JsonNullValueInput | InputJsonValue
    theta: number
    standardError: number
    level: string
    score: number
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrase?: PhraseUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
    attempts?: SpeakingAttemptUpdateManyWithoutSessionNestedInput
  }

  export type SpeakingSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
    attempts?: SpeakingAttemptUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SpeakingSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bestScore?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalTime?: IntFieldUpdateOperationsInput | number
  }

  export type ListeningSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseType?: StringFieldUpdateOperationsInput | string
    accent?: StringFieldUpdateOperationsInput | string
    speed?: FloatFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseType?: StringFieldUpdateOperationsInput | string
    accent?: StringFieldUpdateOperationsInput | string
    speed?: FloatFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListeningSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    exerciseType?: StringFieldUpdateOperationsInput | string
    accent?: StringFieldUpdateOperationsInput | string
    speed?: FloatFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    score?: IntFieldUpdateOperationsInput | number
    timeSpent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementTestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    theta?: FloatFieldUpdateOperationsInput | number
    standardError?: FloatFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementTestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    theta?: FloatFieldUpdateOperationsInput | number
    standardError?: FloatFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementTestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    answers?: JsonNullValueInput | InputJsonValue
    theta?: FloatFieldUpdateOperationsInput | number
    standardError?: FloatFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    progress?: number
    unlocked?: boolean
    unlockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    unlocked?: BoolFieldUpdateOperationsInput | boolean
    unlockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseCreateManyLevelInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    categoryId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhraseUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneRequiredWithoutPhrasesNestedInput
    progress?: UserProgressUpdateManyWithoutPhraseNestedInput
    speakingAttempts?: SpeakingAttemptUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutPhraseNestedInput
    speakingAttempts?: SpeakingAttemptUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateManyWithoutLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhraseCreateManyCategoryInput = {
    id?: string
    text: string
    translation: string
    audioUrl?: string | null
    imageUrl?: string | null
    levelId: string
    difficulty?: number
    tags?: PhraseCreatetagsInput | string[]
    ipaTranscription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PhraseUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: LevelUpdateOneRequiredWithoutPhrasesNestedInput
    progress?: UserProgressUpdateManyWithoutPhraseNestedInput
    speakingAttempts?: SpeakingAttemptUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutPhraseNestedInput
    speakingAttempts?: SpeakingAttemptUncheckedUpdateManyWithoutPhraseNestedInput
  }

  export type PhraseUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    translation?: StringFieldUpdateOperationsInput | string
    audioUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    levelId?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    tags?: PhraseUpdatetagsInput | string[]
    ipaTranscription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyPhraseInput = {
    id?: string
    userId: string
    mastery?: number
    attempts?: number
    successes?: number
    lastScore?: number
    bestScore?: number
    easeFactor?: number
    interval?: number
    nextReview?: Date | string
    lastPracticed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpeakingAttemptCreateManyPhraseInput = {
    id?: string
    sessionId: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UserProgressUpdateWithoutPhraseInput = {
    id?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutPhraseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutPhraseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mastery?: IntFieldUpdateOperationsInput | number
    attempts?: IntFieldUpdateOperationsInput | number
    successes?: IntFieldUpdateOperationsInput | number
    lastScore?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    easeFactor?: FloatFieldUpdateOperationsInput | number
    interval?: IntFieldUpdateOperationsInput | number
    nextReview?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPracticed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingAttemptUpdateWithoutPhraseInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SpeakingSessionUpdateOneRequiredWithoutAttemptsNestedInput
  }

  export type SpeakingAttemptUncheckedUpdateWithoutPhraseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingAttemptUncheckedUpdateManyWithoutPhraseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingAttemptCreateManySessionInput = {
    id?: string
    phraseId: string
    audioUrl: string
    duration: number
    transcription: string
    overallScore: number
    accuracy: number
    fluency: number
    completeness: number
    prosody: number
    feedback: JsonNullValueInput | InputJsonValue
    mistakes: JsonNullValueInput | InputJsonValue
    phonemes: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SpeakingAttemptUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phrase?: PhraseUpdateOneRequiredWithoutSpeakingAttemptsNestedInput
  }

  export type SpeakingAttemptUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpeakingAttemptUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    phraseId?: StringFieldUpdateOperationsInput | string
    audioUrl?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    transcription?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    accuracy?: IntFieldUpdateOperationsInput | number
    fluency?: IntFieldUpdateOperationsInput | number
    completeness?: IntFieldUpdateOperationsInput | number
    prosody?: IntFieldUpdateOperationsInput | number
    feedback?: JsonNullValueInput | InputJsonValue
    mistakes?: JsonNullValueInput | InputJsonValue
    phonemes?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateManyTeacherInput = {
    id?: string
    studentId: string
    scheduledAt: Date | string
    duration: number
    status?: string
    meetingUrl?: string | null
    notes?: string | null
    feedback?: string | null
    price: number
    paid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: UserUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    meetingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    paid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementCountOutputTypeDefaultArgs instead
     */
    export type AchievementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LevelCountOutputTypeDefaultArgs instead
     */
    export type LevelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LevelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhraseCountOutputTypeDefaultArgs instead
     */
    export type PhraseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhraseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakingSessionCountOutputTypeDefaultArgs instead
     */
    export type SpeakingSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakingSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherCountOutputTypeDefaultArgs instead
     */
    export type TeacherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GamificationDefaultArgs instead
     */
    export type GamificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GamificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LevelDefaultArgs instead
     */
    export type LevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LevelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhraseDefaultArgs instead
     */
    export type PhraseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhraseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProgressDefaultArgs instead
     */
    export type UserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakingSessionDefaultArgs instead
     */
    export type SpeakingSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakingSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpeakingAttemptDefaultArgs instead
     */
    export type SpeakingAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpeakingAttemptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListeningSessionDefaultArgs instead
     */
    export type ListeningSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ListeningSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementTestDefaultArgs instead
     */
    export type PlacementTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementTestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherDefaultArgs instead
     */
    export type TeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LessonDefaultArgs instead
     */
    export type LessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LessonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}